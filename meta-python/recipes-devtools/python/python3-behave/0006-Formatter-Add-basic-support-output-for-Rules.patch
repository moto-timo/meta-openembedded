From 9346ffb2aa6841e32fa69709ac360aa7bfb16763 Mon Sep 17 00:00:00 2001
From: jenisys <jenisys@users.noreply.github.com>
Date: Wed, 13 Mar 2019 23:08:19 +0100
Subject: [PATCH] Formatter: Add basic support/output for Rules.

---
 behave/formatter/base.py     | 18 +++++------
 behave/formatter/plain.py    | 63 +++++++++++++++++++++++++++++-------
 behave/formatter/pretty.py   | 33 +++++++++++++++----
 behave/formatter/progress.py | 18 ++++++++++-
 behave/model.py              | 14 ++++----
 5 files changed, 110 insertions(+), 36 deletions(-)

diff --git a/behave/formatter/base.py b/behave/formatter/base.py
index f7268fa..a8b9f7c 100644
--- a/behave/formatter/base.py
+++ b/behave/formatter/base.py
@@ -129,15 +129,6 @@ class Formatter(object):
         """
         pass
 
-    def background(self, background):
-        """Called when a (Feature) Background is provided.
-        Called after :method:`feature()` is called.
-        Called before processing any scenarios or scenario outlines.
-
-        :param background:  Background object (as :class:`behave.model.Background`)
-        """
-        pass
-
     def rule(self, rule):
         """Called before a rule is executed.
 
@@ -153,6 +144,15 @@ class Formatter(object):
     #     """
     #     pass
 
+    def background(self, background):
+        """Called when a (Feature) Background is provided.
+        Called after :method:`feature()` is called.
+        Called before processing any scenarios or scenario outlines.
+
+        :param background:  Background object (as :class:`behave.model.Background`)
+        """
+        pass
+
     def scenario(self, scenario):
         """Called before a scenario is executed (or ScenarioOutline scenarios).
 
diff --git a/behave/formatter/plain.py b/behave/formatter/plain.py
index 9f1f833..e720829 100644
--- a/behave/formatter/plain.py
+++ b/behave/formatter/plain.py
@@ -23,6 +23,8 @@ class PlainFormatter(Formatter):
 
     SHOW_MULTI_LINE = True
     SHOW_TAGS = False
+    SHOW_RULES = True
+    SHOW_BACKGROUNDS = True
     SHOW_ALIGNED_KEYWORDS = False
     DEFAULT_INDENT_SIZE = 2
     RAISE_OUTPUT_ERRORS = True
@@ -35,6 +37,7 @@ class PlainFormatter(Formatter):
         self.show_aligned_keywords = self.SHOW_ALIGNED_KEYWORDS
         self.show_tags = self.SHOW_TAGS
         self.indent_size = self.DEFAULT_INDENT_SIZE
+        self.current_rule = None
         # -- ENSURE: Output stream is open.
         self.stream = self.open()
         self.printer = ModelPrinter(self.stream)
@@ -49,6 +52,10 @@ class PlainFormatter(Formatter):
                 offset = 2
             indentation = make_indentation(3 * self.indent_size + offset)
             self._multiline_indentation = indentation
+
+        if self.current_rule:
+            indent_extra = make_indentation(self.indent_size)
+            return self._multiline_indentation + indent_extra
         return self._multiline_indentation
 
     def reset_steps(self):
@@ -60,37 +67,69 @@ class PlainFormatter(Formatter):
             text = " @".join(tags)
             self.stream.write(u"%s@%s\n" % (indent, text))
 
+    def write_entity(self, entity, indent="", has_tags=True):
+        if has_tags:
+            self.write_tags(entity.tags, indent)
+        text = u"%s%s: %s\n" % (indent, entity.keyword, entity.name)
+        self.stream.write(text)
+
     # -- IMPLEMENT-INTERFACE FOR: Formatter
     def feature(self, feature):
+        self.current_rule = None
         self.reset_steps()
-        self.write_tags(feature.tags)
-        self.stream.write(u"%s: %s\n" % (feature.keyword, feature.name))
+        self.write_entity(feature)
+        # self.write_tags(feature.tags)
+        # self.stream.write(u"%s: %s\n" % (feature.keyword, feature.name))
 
-    def background(self, background):
+    def rule(self, rule):
+        self.current_rule = rule
         self.reset_steps()
         indent = make_indentation(self.indent_size)
-        text = u"%s%s: %s\n" % (indent, background.keyword, background.name)
-        self.stream.write(text)
+        self.stream.write(u"\n")
+        self.write_entity(rule, indent)
+        # self.stream.write(u"%s%s: %s\n" % (indent, rule.keyword, rule.name))
+
+    def background(self, background):
+        self.reset_steps()
+        if not self.SHOW_BACKGROUNDS:
+            return
+
+        indent_extra = 0
+        if self.current_rule:
+            indent_extra = self.indent_size
+
+        indent = make_indentation(self.indent_size + indent_extra)
+        self.write_entity(background, indent, has_tags=False)
+        # text = u"%s%s: %s\n" % (indent, background.keyword, background.name)
+        # self.stream.write(text)
 
     def scenario(self, scenario):
+        indent_extra = 0
+        if self.current_rule:
+            indent_extra = self.indent_size
+
         self.reset_steps()
         self.stream.write(u"\n")
-        indent = make_indentation(self.indent_size)
-        text = u"%s%s: %s\n" % (indent, scenario.keyword, scenario.name)
-        self.write_tags(scenario.tags, indent)
-        self.stream.write(text)
+        indent = make_indentation(self.indent_size + indent_extra)
+        self.write_entity(scenario, indent)
+        # text = u"%s%s: %s\n" % (indent, scenario.keyword, scenario.name)
+        # self.write_tags(scenario.tags, indent)
+        # self.stream.write(text)
 
     def step(self, step):
         self.steps.append(step)
 
     def result(self, step):
-        """
-        Process the result of a step (after step execution).
+        """Process the result of a step (after step execution).
 
         :param step:   Step object with result to process.
         """
+        indent_extra = 0
+        if self.current_rule:
+            indent_extra = self.indent_size
+
         step = self.steps.pop(0)
-        indent = make_indentation(2 * self.indent_size)
+        indent = make_indentation(2 * self.indent_size + indent_extra)
         if self.show_aligned_keywords:
             # -- RIGHT-ALIGN KEYWORDS (max. keyword width: 6):
             text = u"%s%6s %s ... " % (indent, step.keyword, step.name)
diff --git a/behave/formatter/pretty.py b/behave/formatter/pretty.py
index b6f0eac..794e1d7 100644
--- a/behave/formatter/pretty.py
+++ b/behave/formatter/pretty.py
@@ -6,7 +6,7 @@ from behave.formatter.ansi_escapes import escapes, up
 from behave.formatter.base import Formatter
 from behave.model_core import Status
 from behave.model_describe import escape_cell, escape_triple_quotes
-from behave.textutil import indent, text as _text
+from behave.textutil import indent, make_indentation, text as _text
 import six
 from six.moves import range, zip
 
@@ -86,6 +86,7 @@ class PrettyFormatter(Formatter):
 
     def reset(self):
         # -- UNUSED: self.tag_statement = None
+        self.current_rule = None
         self.steps = []
         self._uri = None
         self._match = None
@@ -99,7 +100,9 @@ class PrettyFormatter(Formatter):
 
     def feature(self, feature):
         #self.print_comments(feature.comments, '')
-        self.print_tags(feature.tags, '')
+        self.current_rule = None
+        prefix = ""
+        self.print_tags(feature.tags, prefix)
         self.stream.write(u"%s: %s" % (feature.keyword, feature.name))
         if self.show_source:
             # pylint: disable=redefined-builtin
@@ -109,6 +112,11 @@ class PrettyFormatter(Formatter):
         self.print_description(feature.description, "  ", False)
         self.stream.flush()
 
+    def rule(self, rule):
+        self.replay()
+        self.current_rule = rule
+        self.statement = rule
+
     def background(self, background):
         self.replay()
         self.statement = background
@@ -176,6 +184,10 @@ class PrettyFormatter(Formatter):
         self.stream.flush()
 
     def table(self, table):
+        prefix = u"      "
+        if self.current_rule:
+            prefix += u"  "
+
         cell_lengths = []
         all_rows = [table.headings] + table.rows
         for row in all_rows:
@@ -189,7 +201,7 @@ class PrettyFormatter(Formatter):
         for i, row in enumerate(all_rows):
             #for comment in row.comments:
             #    self.stream.write("      %s\n" % comment.value)
-            self.stream.write("      |")
+            self.stream.write(u"%s|" % prefix)
             for j, (cell, max_length) in enumerate(zip(row, max_lengths)):
                 self.stream.write(" ")
                 self.stream.write(self.color(cell, None, j))
@@ -202,6 +214,8 @@ class PrettyFormatter(Formatter):
         #self.stream.write('      """' + doc_string.content_type + '\n')
         doc_string = _text(doc_string)
         prefix = u"      "
+        if self.current_rule:
+            prefix += u"  "
         self.stream.write(u'%s"""\n' % prefix)
         doc_string = escape_triple_quotes(indent(doc_string, prefix))
         self.stream.write(doc_string)
@@ -251,12 +265,16 @@ class PrettyFormatter(Formatter):
         if self.statement is None:
             return
 
+        prefix = u"  "
+        if self.current_rule and self.statement.type != "rule":
+            prefix += prefix
+
         self.calculate_location_indentations()
         self.stream.write(u"\n")
         #self.print_comments(self.statement.comments, "  ")
         if hasattr(self.statement, "tags"):
-            self.print_tags(self.statement.tags, u"  ")
-        self.stream.write(u"  %s: %s " % (self.statement.keyword,
+            self.print_tags(self.statement.tags, prefix)
+        self.stream.write(u"%s%s: %s " % (prefix, self.statement.keyword,
                                           self.statement.name))
 
         location = self.indented_text(six.text_type(self.statement.location), True)
@@ -279,8 +297,11 @@ class PrettyFormatter(Formatter):
         text_format = self.format(status.name)
         arg_format = self.arg_format(status.name)
 
+        prefix = u"    "
+        if self.current_rule:
+            prefix += u"  "
         #self.print_comments(step.comments, "    ")
-        self.stream.write("    ")
+        self.stream.write(prefix)
         self.stream.write(text_format.text(step.keyword + " "))
         line_length = 5 + len(step.keyword)
 
diff --git a/behave/formatter/progress.py b/behave/formatter/progress.py
index 6d8adf6..3b471ed 100644
--- a/behave/formatter/progress.py
+++ b/behave/formatter/progress.py
@@ -43,6 +43,7 @@ class ProgressFormatterBase(Formatter):
         self.steps = []
         self.failures = []
         self.current_feature = None
+        self.current_rule = None
         self.current_scenario = None
         self.show_timings = config.show_timings and self.show_timings
 
@@ -50,14 +51,19 @@ class ProgressFormatterBase(Formatter):
         self.steps = []
         self.failures = []
         self.current_feature = None
+        self.current_rule = None
         self.current_scenario = None
 
     # -- FORMATTER API:
     def feature(self, feature):
+        self.current_rule = None
         self.current_feature = feature
         self.stream.write("%s  " % six.text_type(feature.filename))
         self.stream.flush()
 
+    def rule(self, rule):
+        self.current_rule = rule
+
     def background(self, background):
         pass
 
@@ -219,9 +225,16 @@ class ScenarioStepProgressFormatter(StepProgressFormatter):
 
     # -- FORMATTER API:
     def feature(self, feature):
+        self.current_rule = None
         self.current_feature = feature
         self.stream.write(u"%s    # %s" % (feature.name, feature.filename))
 
+    def rule(self, rule):
+        self.current_rule = rule
+        self.stream.write(u"\n\n  %s: %s    # %s" %
+                          (rule.keyword, rule.name, rule.location))
+        self.stream.flush()
+
     def scenario(self, scenario):
         """Process the next scenario."""
         # -- LAST SCENARIO: Report failures (if any).
@@ -231,9 +244,12 @@ class ScenarioStepProgressFormatter(StepProgressFormatter):
         assert not self.failures
         self.current_scenario = scenario
         scenario_name = scenario.name
+        prefix = self.scenario_prefix
+        if self.current_rule:
+            prefix += u"  "
         if scenario_name:
             scenario_name += " "
-        self.stream.write(u"%s%s " % (self.scenario_prefix, scenario_name))
+        self.stream.write(u"%s%s " % (prefix, scenario_name))
         self.stream.flush()
 
     # -- DISABLED:
diff --git a/behave/model.py b/behave/model.py
index 6238313..3084850 100644
--- a/behave/model.py
+++ b/behave/model.py
@@ -318,10 +318,10 @@ class ScenarioContainer(TagAndStatusStatement, Replayable):
         runner.context.tags = set(self.tags)
 
         skip_entity_untested = runner.aborted
-        run_entity = self.should_run(runner.config)
+        should_run_entity = self.should_run(runner.config)
         failed_count = 0
         hooks_called = False
-        if not runner.config.dry_run and run_entity:
+        if not runner.config.dry_run and should_run_entity:
             hooks_called = True
             for tag in self.tags:
                 runner.run_hook("before_tag", runner.context, tag)
@@ -332,10 +332,10 @@ class ScenarioContainer(TagAndStatusStatement, Replayable):
             # -- RE-EVALUATE SHOULD-RUN STATE:
             # Hook may call entity.mark_skipped() to exclude it.
             skip_entity_untested = self.hook_failed or runner.aborted
-            run_entity = self.should_run()
+            should_run_entity = self.should_run()
 
         # run this entity if the tags say so or any one of its scenarios
-        if run_entity or runner.config.show_skipped:
+        if should_run_entity or runner.config.show_skipped:
             for formatter in runner.formatters:
                 formatter_callback = getattr(formatter, entity_name, None)
                 if formatter_callback:
@@ -363,7 +363,7 @@ class ScenarioContainer(TagAndStatusStatement, Replayable):
                         break
 
         self.clear_status()  # -- ENFORCE: compute_status() after run.
-        if not self.run_items and not run_entity:
+        if not self.run_items and not should_run_entity:
             # -- SPECIAL CASE: Feature without scenarios
             self.set_status(Status.skipped)
 
@@ -382,7 +382,7 @@ class ScenarioContainer(TagAndStatusStatement, Replayable):
             # -- CLEANUP-ERROR:
             self.set_status(Status.failed)
 
-        if run_entity or runner.config.show_skipped:
+        if should_run_entity or runner.config.show_skipped:
             callback_name = "{0}_finished".format(entity_name)
             if entity_name == "feature":
                 callback_name = "eof"
@@ -608,7 +608,6 @@ class Rule(ScenarioContainer):
     .. versionadded:: 1.2.7
     .. _`feature`: gherkin.html#rule
     """
-
     type = "rule"
 
     def __init__(self, filename, line, keyword, name, tags=None,
@@ -625,7 +624,6 @@ class Rule(ScenarioContainer):
             (self.name, len(self.scenarios))
 
 
-
 class Background(BasicStatement, Replayable):
     """A `background`_ parsed from a *feature file*.
 
