From aadc2e89f3f584bfab68c7fdbdc7a3c7502db2c2 Mon Sep 17 00:00:00 2001
From: jenisys <jenisys@users.noreply.github.com>
Date: Wed, 10 Jul 2019 22:38:13 +0200
Subject: [PATCH] Improve support for feature.background inheritance for
 rule.background.

---
 .gitignore                                    |   3 +
 behave/model.py                               | 230 ++++++++++--
 behave/parser.py                              |   9 +-
 .../fixture.override_background/README.rst    | 116 ------
 .../behave_fixture_lib/__init__.py            |   0
 .../behave_fixture_lib/override_background.py |  80 -----
 .../features/environment.py                   |  35 --
 .../features/example.feature                  |  18 -
 .../features/steps/basic_steps.py             |  13 -
 .../features/steps/use_steplib_behave4cmd.py  |  12 -
 setup.py                                      |   1 +
 tests/unit/test_model.py                      | 117 +-----
 tests/unit/test_model2.py                     |   4 -
 tests/unit/test_model_core.py                 | 116 +++++-
 tests/unit/test_parser_gherkin_v6.py          | 339 +++++++++++++++++-
 15 files changed, 645 insertions(+), 448 deletions(-)
 delete mode 100644 examples/fixture.override_background/README.rst
 delete mode 100644 examples/fixture.override_background/behave_fixture_lib/__init__.py
 delete mode 100644 examples/fixture.override_background/behave_fixture_lib/override_background.py
 delete mode 100644 examples/fixture.override_background/features/environment.py
 delete mode 100644 examples/fixture.override_background/features/example.feature
 delete mode 100644 examples/fixture.override_background/features/steps/basic_steps.py
 delete mode 100644 examples/fixture.override_background/features/steps/use_steplib_behave4cmd.py

diff --git a/.gitignore b/.gitignore
index 6196a6d..9c5c33d 100644
--- a/.gitignore
+++ b/.gitignore
@@ -7,6 +7,9 @@ build/
 dist/
 __pycache__/
 __WORKDIR__/
+__*/
+__*.txt
+__*.rst
 _build/
 _WORKSPACE/
 reports/
diff --git a/behave/model.py b/behave/model.py
index 7fc534a..69f38ab 100644
--- a/behave/model.py
+++ b/behave/model.py
@@ -29,6 +29,36 @@ else:
     import traceback
 
 
+# ---------------------------------------------------------------------------
+# MODEL UTILITIES:
+# ---------------------------------------------------------------------------
+def reset_steps(steps):
+    for step in steps:
+        step.reset()
+    return steps
+
+
+def copy_steps(steps):
+    """Copy steps; needed if steps should be used in multiple run contexts.
+
+    :param steps:       List of steps to copy.
+    :return: List of copied steps.
+    """
+    return [copy.copy(step) for step in steps]
+
+
+def copy_and_reset_steps(steps):
+    """Copy steps and reset each step (status, duration, etc.)
+
+    :param steps:       List of steps to copy.
+    :return: List of copied steps.
+    """
+    return reset_steps(copy_steps(steps))
+
+
+# ---------------------------------------------------------------------------
+# MODEL CLASSES:
+# ---------------------------------------------------------------------------
 class ScenarioContainer(TagAndStatusStatement, Replayable):
     """Abstract base class for model elements
     that contains the following structure:
@@ -198,8 +228,8 @@ class ScenarioContainer(TagAndStatusStatement, Replayable):
 
         if skipped:
             return Status.skipped
-        else:
-            return Status.passed
+        # -- OTHERWISE:
+        return Status.passed
 
     @property
     def duration(self):
@@ -230,7 +260,8 @@ class ScenarioContainer(TagAndStatusStatement, Replayable):
                 rule = run_item
                 if with_rules:
                     all_scenarios.append(rule)
-                all_scenarios.extend(rule.walk_scenarios(with_outlines=with_outlines))
+                scenarios = rule.walk_scenarios(with_outlines=with_outlines)
+                all_scenarios.extend(scenarios)
             elif isinstance(run_item, ScenarioOutline):
                 scenario_outline = run_item
                 if with_outlines:
@@ -241,6 +272,16 @@ class ScenarioContainer(TagAndStatusStatement, Replayable):
                 all_scenarios.append(run_item)
         return all_scenarios
 
+    def iter_scenarios(self):
+        return iter(self.walk_scenarios())
+
+    def iter_scenario_outlines(self):
+        return iter([x for x in self.walk_scenarios(with_outlines=True)
+                     if isinstance(x, ScenarioOutline)])
+
+    def iter_rules(self):
+        return iter([x for x in self.run_items if isinstance(x, Rule)])
+
     def should_run(self, config=None):
         """
         Determines if this Feature (and its scenarios) should run.
@@ -312,7 +353,7 @@ class ScenarioContainer(TagAndStatusStatement, Replayable):
         :param runner:  Runner to use.
         :return: True, if test-run failed.
         """
-        # pylint: disable=too-many-branches
+        # pylint: disable=too-many-branches, too-many-locals, too-many-statements
         # MAYBE: self.reset()
         self.clear_status()
         self.hook_failed = False
@@ -387,7 +428,7 @@ class ScenarioContainer(TagAndStatusStatement, Replayable):
         # -- PERFORM CONTEXT CLEANUP: May raise cleanup errors.
         try:
             runner.context._pop()       # pylint: disable=protected-access
-        except Exception:
+        except Exception:               # pylint: disable=broad-except
             # -- CLEANUP-ERROR:
             self.set_status(Status.failed)
 
@@ -509,16 +550,28 @@ class Feature(ScenarioContainer):
     def _setup_context_for_run(self, context):
         context.feature = self
 
+    def add_background(self, background):
+        self.background = background
+        self.background.parent = self
+
     def add_rule(self, rule):
-        """Add a rule to this feature."""
+        """Add a rule to this feature (supported in: Gherkin v6).
+
+        .. versionadded: 1.2.7
+        """
         feature = self
         rule.parent = feature
         rule.feature = feature
-        if not rule.background:
-            # -- MAYBE: Inherit feature.background if the rule has no background.
-            rule.background = self.background
         self.rules.append(rule)
         self.run_items.append(rule)
+        if self.background:
+            # -- ENSURE: Rule inherits feature.background.
+            if not rule.background:
+                # -- ENSURE: Rule has a default background.
+                # Necessary to inherit feature.background (or disable it).
+                rule_default_background = Background(rule.filename, rule.line)
+                rule.add_background(rule_default_background)
+            rule.background.inherited_background = self.background
 
 
 class Rule(ScenarioContainer):
@@ -630,6 +683,7 @@ class Rule(ScenarioContainer):
                                    description, scenarios, background)
         self.parent = parent
         self.feature = parent
+        self._use_background_inheritance = True
 
     def _setup_context_for_run(self, context):
         context.rule = self
@@ -638,10 +692,43 @@ class Rule(ScenarioContainer):
         return '<Rule "%s": %d scenario(s)>' % \
             (self.name, len(self.scenarios))
 
+    def add_background(self, background, inherited=None):
+        if inherited is None:
+            feature = self.feature or self.parent
+            inherited = feature.background
+
+        self.background = background
+        self.background.inherited_background = inherited
+        self.background.use_inheritance = self.use_background_inheritance
+        self.background.parent = self
+        # -- ENSURE: Normally background is added before scenarios.
+        for scenario in self.walk_scenarios():
+            scenario.background = self.background
+
+    @property
+    def use_background_inheritance(self):
+        return self._use_background_inheritance
+
+    @use_background_inheritance.setter
+    def use_background_inheritance(self, value):
+        self._use_background_inheritance = value
+        if self.background:
+            self.background.use_inheritance = value
+
 
 class Background(BasicStatement, Replayable):
     """A `background`_ parsed from a *feature file*.
 
+    Behaviour:
+
+    * Each scenario of a scenario container (Feature, Rule)
+      inherits the Background of its scenario container
+    * Background steps in a scenario are executed before scenario steps
+    * Rule Background inherits the Feature Background (outer background) if any
+    * Inherited Background steps are used/executed first
+    * Optionally, background inheritance can be disabled
+      (normally: by using a fixture/fixture-tag)
+
     The attributes are:
 
     .. attribute:: keyword
@@ -679,23 +766,65 @@ class Background(BasicStatement, Replayable):
 
     .. _`background`: gherkin.html#backgrounds
     """
-    # TODO: Background inheritance
-    # Rule.background should inherit its Feature.background steps (if available)
-    # Rule.background = Feature.background iff not Rule.background exists (ALREADY-SOLVED)
-    # Rule may override background inheritance mechanism
     type = "background"
 
-    def __init__(self, filename, line, keyword, name, steps=None, description=None):
+    def __init__(self, filename, line, keyword=u"Background", name=u"",
+                 steps=None, description=None):
         super(Background, self).__init__(filename, line, keyword, name)
         self.description = description or []
         self.steps = steps or []
+        self.inherited_background = None
+        self._inherited_steps = None
+        self._use_inheritance = True
 
-    def __repr__(self):
-        return '<Background "%s">' % self.name
+    @property
+    def use_inheritance(self):
+        """Indicates if this Background should inherit from an outer Background.
+        Background inheritance mechanism is enabled (per default).
+        Optionally, this mechanism can be disabled (or overridden).
 
-    def __iter__(self):
+        :return: Current background inheritance state (as bool).
+
+        .. versionadded:: 1.2.7
+        """
+        return self._use_inheritance
+
+    @use_inheritance.setter
+    def use_inheritance(self, value):
+        """Enable/disable background inheritance mechanism for this Background.
+
+        :param value:   New value (as bool).
+
+        .. versionadded:: 1.2.7
+        """
+        # -- ENSURE: inherited_steps are reinitialized (later).
+        self._use_inheritance = bool(value)
+        self._inherited_steps = None
+
+    @property
+    def inherited_steps(self):
+        # versionadded:: 1.2.7
+        if self._inherited_steps is None:
+            # -- LAZY-INIT: Support enable/disable the inheritance mechanism.
+            steps = []
+            if self.inherited_background and self._use_inheritance:
+                steps = copy_and_reset_steps(self.inherited_background.steps)
+            self._inherited_steps = steps
+        return self._inherited_steps
+
+    def iter_steps(self):
+        """Returns iterator to all steps, including inherited steps (if any).
+
+        .. versionadded:: 1.2.7
+        """
+        if self.inherited_steps:
+            return itertools.chain(self.inherited_steps, self.steps)
         return iter(self.steps)
 
+    @property
+    def all_steps(self):
+        return self.iter_steps()
+
     @property
     def duration(self):
         duration = 0
@@ -703,6 +832,12 @@ class Background(BasicStatement, Replayable):
             duration += step.duration
         return duration
 
+    def __repr__(self):
+        return '<Background "%s">' % self.name
+
+    def __iter__(self):
+        return self.iter_steps()
+
 
 class Scenario(TagAndStatusStatement, Replayable):
     """A `scenario`_ parsed from a *feature file*.
@@ -799,6 +934,7 @@ class Scenario(TagAndStatusStatement, Replayable):
         self.feature = None  # REFER-TO: owner=Feature
         self.hook_failed = False
         self._background_steps = None
+        self._use_background = True
         self._row = None
         self.was_dry_run = False
 
@@ -813,6 +949,27 @@ class Scenario(TagAndStatusStatement, Replayable):
         for step in self.all_steps:
             step.reset()
 
+    @property
+    def use_background(self):
+        """Indicates if the background is/would be used (if any exists).
+        NOTE: The Background (steps) are normally used.
+
+        .. versionadded:: 1.2.7
+        """
+        return self._use_background
+
+    @use_background.setter
+    def use_background(self, value):
+        """Enable/disable the usage of the background (steps).
+
+        :param value:  New value (as bool).
+
+        .. versionadded:: 1.2.7
+        """
+        # -- ENSURE: background_steps are reinitialized.
+        self._use_background = value
+        self._background_steps = None
+
     @property
     def background_steps(self):
         """Provide background steps if feature/rule has a background.
@@ -828,24 +985,29 @@ class Scenario(TagAndStatusStatement, Replayable):
             # Each scenario needs own background.steps.
             # Otherwise, background step status of the last-run scenario is used.
             steps = []
-            if self.background:
-                steps = [copy.copy(step) for step in self.background.steps]
+            if self.background and self.use_background:
+                steps = copy_and_reset_steps(self.background.all_steps)
             self._background_steps = steps
         return self._background_steps
 
-    @property
-    def all_steps(self):
-        """Returns iterator to all steps, including background steps if any."""
+    def iter_steps(self):
+        """Returns iterator to all steps, including background steps if any.
+
+        .. versionadded:: 1.2.7
+        """
         if self.background is not None:
             return itertools.chain(self.background_steps, self.steps)
-        else:
-            return iter(self.steps)
+        return iter(self.steps)
+
+    @property
+    def all_steps(self):
+        return self.iter_steps()
 
     def __repr__(self):
         return '<Scenario "%s">' % self.name
 
     def __iter__(self):
-        return self.all_steps
+        return self.iter_steps()
 
     def compute_status(self):
         """Compute the status of the scenario from its steps
@@ -862,9 +1024,8 @@ class Scenario(TagAndStatusStatement, Replayable):
                     # -- SPECIAL CASE: In dry-run with undefined-step discovery
                     #    Undefined steps should not cause failed scenario.
                     return Status.untested
-                else:
-                    # -- NORMALLY: Undefined steps cause failed scenario.
-                    return Status.failed
+                # -- NORMALLY: Undefined steps cause failed scenario.
+                return Status.failed
             elif step.status != Status.passed:
                 # pylint: disable=line-too-long
                 assert step.status in (Status.failed, Status.skipped, Status.untested)
@@ -1029,7 +1190,6 @@ class Scenario(TagAndStatusStatement, Replayable):
                     # BUT: Detect all remaining undefined steps.
                     step.status = Status.skipped
                     if dry_run_scenario:
-                        # pylint: disable=redefined-variable-type
                         step.status = Status.untested
                     found_step_match = runner.step_registry.find_match(step)
                     if not found_step_match:
@@ -1067,7 +1227,7 @@ class Scenario(TagAndStatusStatement, Replayable):
         # -- PERFORM CONTEXT-CLEANUP: May raise cleanup errors.
         try:
             runner.context._pop()       # pylint: disable=protected-access
-        except Exception:
+        except Exception:               # pylint: disable=broad-except
             self.set_status(Status.failed)
             failed = True
 
@@ -1176,9 +1336,9 @@ class ScenarioOutlineBuilder(object):
                 placeholder = u"<%s>" % name
                 for i, cell in enumerate(new_step.table.headings):
                     new_step.table.headings[i] = cell.replace(placeholder, value)
-                for row in new_step.table:
-                    for i, cell in enumerate(row.cells):
-                        row.cells[i] = cell.replace(placeholder, value)
+                for step_row in new_step.table:
+                    for i, cell in enumerate(step_row.cells):
+                        step_row.cells[i] = cell.replace(placeholder, value)
         return new_step
 
     def build_scenarios(self, scenario_outline):
@@ -1640,7 +1800,6 @@ class Step(BasicStatement, Replayable):
                 match.run(runner.context)
                 if self.status == Status.untested:
                     # -- NOTE: Executed step may have skipped scenario and itself.
-                    # pylint: disable=redefined-variable-type
                     self.status = Status.passed
             except KeyboardInterrupt as e:
                 runner.aborted = True
@@ -1815,8 +1974,7 @@ class Table(Replayable):
         """
         if self.has_column(column_name):
             return self.get_column_index(column_name)
-        else:
-            return self.add_column(column_name)
+        return self.add_column(column_name)
 
     def __repr__(self):
         return "<Table: %dx%d>" % (len(self.headings), len(self.rows))
diff --git a/behave/parser.py b/behave/parser.py
index 993c9dc..520f678 100644
--- a/behave/parser.py
+++ b/behave/parser.py
@@ -249,7 +249,6 @@ class Parser(object):
         self.rule = rule
         self.scenario_container = rule
         self.statement = rule
-        # MAYBE: self.background = None
         self.feature.add_rule(self.statement)
         # -- RESET STATE:
         self.tags = []
@@ -258,11 +257,15 @@ class Parser(object):
         if self.tags:
             msg = u"Background supports no tags: @%s" % (u" @".join(self.tags))
             raise ParserError(msg, self.line, self.filename, line)
+        elif self.scenario_container and self.scenario_container.background:
+            if self.scenario_container.background.steps:
+                # -- HINT: Rule may have default background w/o steps.
+                msg = u"Second Background (can have only one)"
+                raise ParserError(msg, self.line, self.filename, line)
         name = line[len(keyword) + 1:].strip()
         background = model.Background(self.filename, self.line, keyword, name)
+        self.scenario_container.add_background(background)
         self.statement = background
-        self.scenario_container.background = background
-        # OLD: self.feature.background = self.statement
 
     def _build_scenario_statement(self, keyword, line):
         name = line[len(keyword) + 1:].strip()
diff --git a/examples/fixture.override_background/README.rst b/examples/fixture.override_background/README.rst
deleted file mode 100644
index 9c150cc..0000000
--- a/examples/fixture.override_background/README.rst
+++ /dev/null
@@ -1,116 +0,0 @@
-EXAMPLE: Override / Disable Background Inheritance Mechanism for Scenario
-===============================================================================
-
-:RELATED-TO: #756
-
-This example shows how the Background inheritance mechanism in Gherkin
-can be disabled in ``behave``.
-
-Parts of the recipe:
-
-* features/example.feature (Feature file as example)
-* features/environment.py (glue code and hooks for fixture-tag / fixture)
-* behave_fixture_lib/override_background.py (fixture implementation, workhorse)
-
-
-.. warning:: BEWARE: This shows you how can do it, not that you should do it
-
-    BETTER:
-
-    * Use Rules to group Scenarios, each with its own Background (in Gherkin v6)
-    * Split Feature aspects into multiple feature files (if needed)
-    * ... (see issue #756 above)
-
-
-Explanation
-------------------------------------------------------------------------
-
-Example code how to provide a behave fixture to disable the
-background inheritance mechanism by using a fixture / fixture-tag.
-The fixture-tag "@ixture.behave.override_background" marks the
-location in Gherkin (which Scenario) where the fixture should be used
-
-.. code-block:: gherkin
-
-    # -- FILE: features/example.feature
-    Feature: Show how @fixture.behave.override_background is used
-
-        Background:
-          Given a background step
-
-        Scenario: Alice
-          When a step passes
-          And note that "Background steps are executed here"
-
-        @fixture.behave.overide_background
-        Scenario: Bob
-          Given I need another scenario setup
-          When another step passes
-          And note that "NO-BACKGROUND STEPS are executed here"
-
-When the feature is executed, you see that:
-
-* First Scenario "Alice": Background steps are inherited and executed first.
-* Second Scenario "Bob": No Background step is executed.
-
-.. code-block:: sh
-
-    $ ../../bin/behave -f plain features/example.feature
-    Feature: Override the Background Inheritance Mechanism in some Scenarios
-      Background:
-
-      Scenario: Alice
-        Given a background step passes ... passed
-        When a step passes ... passed
-        And note that "Background steps are executed here" ... passed
-    FIXTURE-HINT: DISABLE-BACKGROUND FOR: Bob
-
-      Scenario: Bob
-        Given I need another scenario setup ... passed
-        When another step passes ... passed
-        And note that "NO-BACKGROUND STEPS are executed here" ... passed
-
-    1 feature passed, 0 failed, 0 skipped
-    2 scenarios passed, 0 failed, 0 skipped
-    6 steps passed, 0 failed, 0 skipped, 0 undefined
-
-
-The environment file provides the glue code that the fixture is called:
-
-.. code-block:: python
-
-    # -- FILE: features/environment.py
-    from behave_fixture_lib.override_background import behave_override_background
-    from behave.fixture import use_fixture_by_tag
-
-    # -- FIXTURE REGISTRY:
-    fixture_registry = {
-        "fixture.behave.overide_background": behave_override_background,
-    }
-
-    # -----------------------------------------------------------------------------
-    # HOOKS:
-    # -----------------------------------------------------------------------------
-    def before_tag(context, tag):
-        if tag.startswith("fixture."):
-            return use_fixture_by_tag(tag, context, fixture_registry)
-
-
-.. code-block:: python
-
-    # -- FILE: behave_fixture_lib/override_background.py (fixture implementation)
-    from behave import fixture
-
-    @fixture(name="fixture.behave.override_background")
-    def behave_override_background(ctx):
-        # -- SETUP-PART-ONLY: Disable background inheritance (for scenarios only).
-        current_scenario = ctx.scenario
-        if current_scenario:
-            behave_disable_background_inheritance_for_scenario(current_scenario)
-
-    # -----------------------------------------------------------------------------
-    # BEHAVE UTILITY:
-    # -----------------------------------------------------------------------------
-    def behave_disable_background_inheritance_for_scenario(scenario):
-        print("FIXTURE-HINT: DISABLE-BACKGROUND FOR: %s" % scenario.name)
-        scenario.background = None
diff --git a/examples/fixture.override_background/behave_fixture_lib/__init__.py b/examples/fixture.override_background/behave_fixture_lib/__init__.py
deleted file mode 100644
index e69de29..0000000
diff --git a/examples/fixture.override_background/behave_fixture_lib/override_background.py b/examples/fixture.override_background/behave_fixture_lib/override_background.py
deleted file mode 100644
index 6c572cf..0000000
--- a/examples/fixture.override_background/behave_fixture_lib/override_background.py
+++ /dev/null
@@ -1,80 +0,0 @@
-# -*- coding: UTF-8 -*-
-# RELATED-TO: #756
-"""
-Example code how to provide a behave fixture to disable the
-background inheritance mechanism.
-
-.. code-block:: gherkin
-
-    # -- FILE: features/example.feature
-    Feature: Show how @fixture.behave.override_background is used
-
-        Background:
-          Given a background step
-
-        Scenario: Alice
-          When a step passes
-          And note that "Background steps are executed here"
-
-        @fixture.behave.overide_background
-        Scenario: Bob
-          Given I need another scenario setup
-          When another step passes
-          And note that "NO-BACKGROUND STEPS are executed here"
-
-.. code-block:: python
-
-    # -- FILE: features/environment.py
-    from behave_fixture_lib.override_background import behave_override_background
-    from behave.fixture import use_fixture_by_tag
-
-    # -- FIXTURE REGISTRY:
-    fixture_registry = {
-        "fixture.behave.overide_background": behave_override_background,
-    }
-
-    def before_tag(context, tag):
-        if tag.startswith("fixture."):
-            return use_fixture_by_tag(tag, context, fixture_registry)
-
-"""
-
-from __future__ import absolute_import, print_function
-from behave import fixture
-
-
-# -----------------------------------------------------------------------------
-# BEHAVE FIXTURES:
-# -----------------------------------------------------------------------------
-@fixture(name="fixture.behave.override_background")
-def behave_override_background(ctx):
-    """Override the Background inherintance mechanism.
-    If a Feature / Rule Background exists in a Feature,
-    all contained Scenarios inherit the Background's steps.
-
-    This fixture disables this mechanism.
-    The tagged Gherkin element will no longer inherit the background steps.
-
-    :param ctx: Context object to use (during a test run).
-    """
-    # -- SETUP-PART-ONLY: Disable background inheritance (for scenarios only).
-    current_scenario = ctx.scenario
-    if current_scenario:
-        behave_disable_background_inheritance_for_scenario(current_scenario)
-
-
-# -----------------------------------------------------------------------------
-# BEHAVE UTILITY:
-# -----------------------------------------------------------------------------
-def behave_disable_background_inheritance_for_scenario(scenario):
-    print("FIXTURE-HINT: DISABLE-BACKGROUND FOR: %s" % scenario.name)
-    scenario.background = None
-    # scenario._background_steps = []
-
-
-# -----------------------------------------------------------------------------
-# MODULE SPECIFIC:
-# -----------------------------------------------------------------------------
-fixture_registry = {
-    "fixture.behave.overide_background": behave_override_background,
-}
diff --git a/examples/fixture.override_background/features/environment.py b/examples/fixture.override_background/features/environment.py
deleted file mode 100644
index 7a4b735..0000000
--- a/examples/fixture.override_background/features/environment.py
+++ /dev/null
@@ -1,35 +0,0 @@
-# -*- coding: UTF-8 -*-
-# -- FILE: features/environment.py
-import os.path
-import sys
-
-# -----------------------------------------------------------------------------
-# PYTHON PATH SETUP:
-# -----------------------------------------------------------------------------
-HERE = os.path.dirname(__file__)
-TOPA = os.path.abspath(os.path.join(HERE, ".."))
-
-def setup_python_path():
-    sys.path.insert(0, TOPA)
-
-setup_python_path()
-
-# -----------------------------------------------------------------------------
-# NORMAL PART:
-# -----------------------------------------------------------------------------
-from behave_fixture_lib.override_background import behave_override_background
-from behave.fixture import use_fixture_by_tag
-
-# -- FIXTURE REGISTRY:
-fixture_registry = {
-    "fixture.behave.overide_background": behave_override_background,
-}
-
-
-# -----------------------------------------------------------------------------
-# HOOKS:
-# -----------------------------------------------------------------------------
-def before_tag(context, tag):
-    if tag.startswith("fixture."):
-        return use_fixture_by_tag(tag, context, fixture_registry)
-
diff --git a/examples/fixture.override_background/features/example.feature b/examples/fixture.override_background/features/example.feature
deleted file mode 100644
index 5ddd874..0000000
--- a/examples/fixture.override_background/features/example.feature
+++ /dev/null
@@ -1,18 +0,0 @@
-Feature: Override the Background Inheritance Mechanism in some Scenarios
-
-  . BEWARE:
-  .   This is only an example how this can be done (PROOF-OF-CONCEPT).
-  .   This is not an example that you should do this !!!
-
-    Background:
-      Given a background step passes
-
-    Scenario: Alice
-      When a step passes
-      And note that "Background steps are executed here"
-
-    @fixture.behave.overide_background
-    Scenario: Bob
-      Given I need another scenario setup
-      When another step passes
-      And note that "NO-BACKGROUND STEPS are executed here"
diff --git a/examples/fixture.override_background/features/steps/basic_steps.py b/examples/fixture.override_background/features/steps/basic_steps.py
deleted file mode 100644
index 34f2107..0000000
--- a/examples/fixture.override_background/features/steps/basic_steps.py
+++ /dev/null
@@ -1,13 +0,0 @@
-from behave import given, step
-
-# @step(u'{word} step passes')
-# def step_passes_with_word(context, word):
-#     pass
-
-@step(u'{word} background step passes')
-def step_background_step_passes(context, word):
-    pass
-
-@given(u'I need {word} scenario setup')
-def step_given_i_need_scenario_setup(context, word):
-    pass
diff --git a/examples/fixture.override_background/features/steps/use_steplib_behave4cmd.py b/examples/fixture.override_background/features/steps/use_steplib_behave4cmd.py
deleted file mode 100644
index bc32a32..0000000
--- a/examples/fixture.override_background/features/steps/use_steplib_behave4cmd.py
+++ /dev/null
@@ -1,12 +0,0 @@
-# -*- coding: utf-8 -*-
-"""
-Use behave4cmd0 step library (predecessor of behave4cmd).
-"""
-
-from __future__ import absolute_import
-
-# -- REGISTER-STEPS FROM STEP-LIBRARY:
-# import behave4cmd0.__all_steps__
-# import behave4cmd0.failing_steps
-import behave4cmd0.passing_steps
-import behave4cmd0.note_steps
diff --git a/setup.py b/setup.py
index cea4392..8de3ec0 100644
--- a/setup.py
+++ b/setup.py
@@ -131,6 +131,7 @@ setup(
         "Programming Language :: Python :: 3.5",
         "Programming Language :: Python :: 3.6",
         "Programming Language :: Python :: 3.7",
+        "Programming Language :: Python :: 3.8",
         "Programming Language :: Python :: Implementation :: CPython",
         "Programming Language :: Python :: Implementation :: Jython",
         "Programming Language :: Python :: Implementation :: PyPy",
diff --git a/tests/unit/test_model.py b/tests/unit/test_model.py
index c1fc424..21d6c27 100644
--- a/tests/unit/test_model.py
+++ b/tests/unit/test_model.py
@@ -8,7 +8,7 @@ from mock import Mock, patch
 import six
 from six.moves import range     # pylint: disable=redefined-builtin
 from six.moves import zip       # pylint: disable=redefined-builtin
-from behave.model_core import FileLocation, Status
+from behave.model_core import Status
 from behave.model import Feature, Scenario, ScenarioOutline, Step
 from behave.model import Table, Row
 from behave.matchers import NoMatch
@@ -20,19 +20,12 @@ from behave import step_registry
 
 if six.PY2:
     # pylint: disable=unused-import
-    import traceback2 as traceback
     traceback_modname = "traceback2"
 else:
     # pylint: disable=unused-import
-    import traceback
     traceback_modname = "traceback"
 
 
-
-# -- CONVENIENCE-ALIAS:
-_text = six.text_type
-
-
 class TestFeatureRun(unittest.TestCase):
     # pylint: disable=invalid-name
 
@@ -769,111 +762,3 @@ class TestModelRow(unittest.TestCase):
         assert data1["name"] == u"Alice"
         assert data1["sex"] == u"female"
         assert data1["age"] == u"12"
-
-
-class TestFileLocation(unittest.TestCase):
-    # pylint: disable=invalid-name
-    ordered_locations1 = [
-        FileLocation("features/alice.feature", 1),
-        FileLocation("features/alice.feature", 5),
-        FileLocation("features/alice.feature", 10),
-        FileLocation("features/alice.feature", 11),
-        FileLocation("features/alice.feature", 100),
-    ]
-    ordered_locations2 = [
-        FileLocation("features/alice.feature", 1),
-        FileLocation("features/alice.feature", 10),
-        FileLocation("features/bob.feature", 5),
-        FileLocation("features/charly.feature", None),
-        FileLocation("features/charly.feature", 0),
-        FileLocation("features/charly.feature", 100),
-    ]
-    same_locations = [
-        (FileLocation("alice.feature"),
-         FileLocation("alice.feature", None),
-        ),
-        (FileLocation("alice.feature", 10),
-         FileLocation("alice.feature", 10),
-        ),
-        (FileLocation("features/bob.feature", 11),
-         FileLocation("features/bob.feature", 11),
-        ),
-    ]
-
-    def test_compare_equal(self):
-        for value1, value2 in self.same_locations:
-            assert value1 == value2
-
-    def test_compare_equal_with_string(self):
-        for location in self.ordered_locations2:
-            assert location == location.filename
-            assert location.filename == location
-
-    def test_compare_not_equal(self):
-        for value1, value2 in self.same_locations:
-            assert not(value1 != value2)    # pylint: disable=unneeded-not, superfluous-parens
-
-        for locations in [self.ordered_locations1, self.ordered_locations2]:
-            for value1, value2 in zip(locations, locations[1:]):
-                assert value1 != value2
-
-    def test_compare_less_than(self):
-        for locations in [self.ordered_locations1, self.ordered_locations2]:
-            for value1, value2 in zip(locations, locations[1:]):
-                assert value1 < value2, "FAILED: %s < %s" % (_text(value1), _text(value2))
-                assert value1 != value2
-
-    def test_compare_less_than_with_string(self):
-        locations = self.ordered_locations2
-        for value1, value2 in zip(locations, locations[1:]):
-            if value1.filename == value2.filename:
-                continue
-            assert value1 < value2.filename, \
-                   "FAILED: %s < %s" % (_text(value1), _text(value2.filename))
-            assert value1.filename < value2, \
-                   "FAILED: %s < %s" % (_text(value1.filename), _text(value2))
-
-    def test_compare_greater_than(self):
-        for locations in [self.ordered_locations1, self.ordered_locations2]:
-            for value1, value2 in zip(locations, locations[1:]):
-                assert value2 > value1, "FAILED: %s > %s" % (_text(value2), _text(value1))
-                assert value2 != value1
-
-    def test_compare_less_or_equal(self):
-        for value1, value2 in self.same_locations:
-            assert value1 <= value2, "FAILED: %s <= %s" % (_text(value1), _text(value2))
-            assert value1 == value2
-
-        for locations in [self.ordered_locations1, self.ordered_locations2]:
-            for value1, value2 in zip(locations, locations[1:]):
-                assert value1 <= value2, "FAILED: %s <= %s" % (_text(value1), _text(value2))
-                assert value1 != value2
-
-    def test_compare_greater_or_equal(self):
-        for value1, value2 in self.same_locations:
-            assert value2 >= value1, "FAILED: %s >= %s" % (_text(value2), _text(value1))
-            assert value2 == value1
-
-        for locations in [self.ordered_locations1, self.ordered_locations2]:
-            for value1, value2 in zip(locations, locations[1:]):
-                assert value2 >= value1, "FAILED: %s >= %s" % (_text(value2), _text(value1))
-                assert value2 != value1
-
-    def test_filename_should_be_same_as_self(self):
-        for location in self.ordered_locations2:
-            assert location == location.filename
-            assert location.filename == location
-
-    def test_string_conversion(self):
-        for location in self.ordered_locations2:
-            expected = u"%s:%s" % (location.filename, location.line)
-            if location.line is None:
-                expected = location.filename
-            assert six.text_type(location) == expected
-
-    def test_repr_conversion(self):
-        for location in self.ordered_locations2:
-            expected = u'<FileLocation: filename="%s", line=%s>' % \
-                       (location.filename, location.line)
-            actual = repr(location)
-            assert actual == expected, "FAILED: %s == %s" % (actual, expected)
diff --git a/tests/unit/test_model2.py b/tests/unit/test_model2.py
index 7884b90..a86b80e 100644
--- a/tests/unit/test_model2.py
+++ b/tests/unit/test_model2.py
@@ -35,10 +35,6 @@ def step_to_text(step, indentation="    "):
     return step_text.rstrip()
 
 
-# -- PYTEST MARKERS/ANNOTATIONS:
-not_implemented_yet = pytest.mark.skip("NOT-IMPLEMENTED-YET")
-
-
 # ----------------------------------------------------------------------------
 # TEST SUITE:
 # ----------------------------------------------------------------------------
diff --git a/tests/unit/test_model_core.py b/tests/unit/test_model_core.py
index b5f20c4..3cb5efa 100644
--- a/tests/unit/test_model_core.py
+++ b/tests/unit/test_model_core.py
@@ -4,10 +4,16 @@
 """
 
 from __future__ import print_function
-from behave.model_core import Status
+import six
+from behave.model_core import Status, FileLocation
 import pytest
 
 
+# -- CONVENIENCE-ALIAS:
+_text = six.text_type
+
+
+
 # -----------------------------------------------------------------------------
 # TESTS:
 # -----------------------------------------------------------------------------
@@ -54,3 +60,111 @@ class TestStatus(object):
     def test_from_name__with_unknown_name_raises_lookuperror(self, unknown_name):
         with pytest.raises(LookupError):
             Status.from_name(unknown_name)
+
+
+class TestFileLocation(object):
+    # pylint: disable=invalid-name
+    ordered_locations1 = [
+        FileLocation("features/alice.feature", 1),
+        FileLocation("features/alice.feature", 5),
+        FileLocation("features/alice.feature", 10),
+        FileLocation("features/alice.feature", 11),
+        FileLocation("features/alice.feature", 100),
+    ]
+    ordered_locations2 = [
+        FileLocation("features/alice.feature", 1),
+        FileLocation("features/alice.feature", 10),
+        FileLocation("features/bob.feature", 5),
+        FileLocation("features/charly.feature", None),
+        FileLocation("features/charly.feature", 0),
+        FileLocation("features/charly.feature", 100),
+    ]
+    same_locations = [
+        (FileLocation("alice.feature"),
+         FileLocation("alice.feature", None),
+        ),
+        (FileLocation("alice.feature", 10),
+         FileLocation("alice.feature", 10),
+        ),
+        (FileLocation("features/bob.feature", 11),
+         FileLocation("features/bob.feature", 11),
+        ),
+    ]
+
+    def test_compare_equal(self):
+        for value1, value2 in self.same_locations:
+            assert value1 == value2
+
+    def test_compare_equal_with_string(self):
+        for location in self.ordered_locations2:
+            assert location == location.filename
+            assert location.filename == location
+
+    def test_compare_not_equal(self):
+        for value1, value2 in self.same_locations:
+            assert not(value1 != value2)    # pylint: disable=unneeded-not, superfluous-parens
+
+        for locations in [self.ordered_locations1, self.ordered_locations2]:
+            for value1, value2 in zip(locations, locations[1:]):
+                assert value1 != value2
+
+    def test_compare_less_than(self):
+        for locations in [self.ordered_locations1, self.ordered_locations2]:
+            for value1, value2 in zip(locations, locations[1:]):
+                assert value1 < value2, "FAILED: %s < %s" % (_text(value1), _text(value2))
+                assert value1 != value2
+
+    def test_compare_less_than_with_string(self):
+        locations = self.ordered_locations2
+        for value1, value2 in zip(locations, locations[1:]):
+            if value1.filename == value2.filename:
+                continue
+            assert value1 < value2.filename, \
+                   "FAILED: %s < %s" % (_text(value1), _text(value2.filename))
+            assert value1.filename < value2, \
+                   "FAILED: %s < %s" % (_text(value1.filename), _text(value2))
+
+    def test_compare_greater_than(self):
+        for locations in [self.ordered_locations1, self.ordered_locations2]:
+            for value1, value2 in zip(locations, locations[1:]):
+                assert value2 > value1, "FAILED: %s > %s" % (_text(value2), _text(value1))
+                assert value2 != value1
+
+    def test_compare_less_or_equal(self):
+        for value1, value2 in self.same_locations:
+            assert value1 <= value2, "FAILED: %s <= %s" % (_text(value1), _text(value2))
+            assert value1 == value2
+
+        for locations in [self.ordered_locations1, self.ordered_locations2]:
+            for value1, value2 in zip(locations, locations[1:]):
+                assert value1 <= value2, "FAILED: %s <= %s" % (_text(value1), _text(value2))
+                assert value1 != value2
+
+    def test_compare_greater_or_equal(self):
+        for value1, value2 in self.same_locations:
+            assert value2 >= value1, "FAILED: %s >= %s" % (_text(value2), _text(value1))
+            assert value2 == value1
+
+        for locations in [self.ordered_locations1, self.ordered_locations2]:
+            for value1, value2 in zip(locations, locations[1:]):
+                assert value2 >= value1, "FAILED: %s >= %s" % (_text(value2), _text(value1))
+                assert value2 != value1
+
+    def test_filename_should_be_same_as_self(self):
+        for location in self.ordered_locations2:
+            assert location == location.filename
+            assert location.filename == location
+
+    def test_string_conversion(self):
+        for location in self.ordered_locations2:
+            expected = u"%s:%s" % (location.filename, location.line)
+            if location.line is None:
+                expected = location.filename
+            assert six.text_type(location) == expected
+
+    def test_repr_conversion(self):
+        for location in self.ordered_locations2:
+            expected = u'<FileLocation: filename="%s", line=%s>' % \
+                       (location.filename, location.line)
+            actual = repr(location)
+            assert actual == expected, "FAILED: %s == %s" % (actual, expected)
diff --git a/tests/unit/test_parser_gherkin_v6.py b/tests/unit/test_parser_gherkin_v6.py
index 991a57d..43e3d41 100644
--- a/tests/unit/test_parser_gherkin_v6.py
+++ b/tests/unit/test_parser_gherkin_v6.py
@@ -227,7 +227,9 @@ Feature: With Rule
         assert rule1.description == []
         assert rule1.tags == []
         assert len(rule1.scenarios) == 1
-        assert rule1.background is feature.background
+        assert rule1.background is not feature.background
+        assert rule1.background.inherited_steps == feature.background.steps
+        assert list(rule1.background.all_steps) == feature.background.steps
         assert_compare_steps(rule1.scenarios[0].all_steps, [
             ("given", "Given", "feature background step 1", None, None),
             ("when", "When", "feature background step 2", None, None),
@@ -235,7 +237,7 @@ Feature: With Rule
             ("when", "When", "scenario step 2", None, None),
         ])
 
-    def test_parses_rule_with_background_should_not_inherit_feature_background(self):
+    def test_parses_rule_with_background_inherits_feature_background(self):
         """If a Rule has no Background,
         it inherits the Feature's Background (if one exists).
         """
@@ -269,13 +271,15 @@ Feature: With Rule
         assert rule1.background is not None
         assert rule1.background is not feature.background
         assert_compare_steps(rule1.scenarios[0].all_steps, [
+            ("given", "Given", "feature background step 1", None, None),
+            ("when",  "When",  "feature background step 2", None, None),
             ("given", "Given", "rule background step 1", None, None),
-            ("when", "When", "rule background step 2", None, None),
+            ("when",  "When",  "rule background step 2", None, None),
             ("given", "Given", "scenario step 1", None, None),
-            ("when", "When", "scenario step 2", None, None),
+            ("when",  "When",  "scenario step 2", None, None),
         ])
 
-    def test_parses_rule_with_empty_background_prevents_inheriting_feature_background(self):
+    def test_parses_rule_with_empty_background_inherits_feature_background(self):
         """A Rule has empty Background (without any steps) prevents that
         Feature Background is inherited (if one exists).
         """
@@ -308,8 +312,10 @@ Feature: With Rule
         assert rule1.background is not feature.background
         assert rule1.background.name == "Rule_R3C.Empty_Background"
         assert_compare_steps(rule1.scenarios[0].all_steps, [
+            ("given", "Given", "feature background step 1", None, None),
+            ("when",  "When",  "feature background step 2", None, None),
             ("given", "Given", "scenario step 1", None, None),
-            ("when", "When", "scenario step 2", None, None),
+            ("when",  "When", "scenario step 2", None, None),
         ])
 
     def test_parses_rule_with_scenario(self):
@@ -558,6 +564,7 @@ Feature: With Rule
             ("when", "When", 'step uses "2"', None, None),
         ])
 
+    # @check.duplicated
     def test_parse_background_scenario_and_rules(self):
         """HINT: Some Scenarios may exist before the first Rule."""
         text = u'''
@@ -606,10 +613,10 @@ Feature: With Scenarios and Rules
         assert scenario1.tags == []
         assert scenario1.description == []
         assert_compare_steps(scenario1.all_steps, [
-            ("given", "Given", 'feature background step_1', None, None),
-            ("when", "When",   'feature background step_2', None, None),
-            ("given", "Given", 'scenario_1 step_1', None, None),
-            ("when", "When",   'scenario_1 step_2', None, None),
+            (u"given", u"Given", u'feature background step_1', None, None),
+            (u"when", u"When",   u'feature background step_2', None, None),
+            (u"given", u"Given", u'scenario_1 step_1', None, None),
+            (u"when", u"When",   u'scenario_1 step_2', None, None),
         ])
 
         assert rule1.name == "R1"
@@ -623,9 +630,11 @@ Feature: With Scenarios and Rules
         assert rule1_scenario1.parent is rule1
         assert rule1_scenario1.feature is feature
         assert_compare_steps(rule1_scenario1.all_steps, [
+            ("given", "Given", 'feature background step_1', None, None),
+            ("when",  "When",  'feature background step_2', None, None),
             ("given", "Given", 'rule R1 background step_1', None, None),
             ("given", "Given", 'rule R1 scenario_1 step_1', None, None),
-            ("when", "When",   'rule R1 scenario_1 step_2', None, None),
+            ("when",  "When",  'rule R1 scenario_1 step_2', None, None),
         ])
 
         assert rule2.name == "R2"
@@ -633,16 +642,318 @@ Feature: With Scenarios and Rules
         assert rule2.feature is feature
         assert rule2.description == []
         assert rule2.tags == []
-        assert rule2.background is feature.background
+        assert rule2.background is not feature.background
+        assert list(rule2.background.inherited_steps) == list(feature.background.steps)
+        assert list(rule2.background.all_steps) == list(feature.background.steps)
         assert len(rule2.scenarios) == 1
         assert rule2_scenario1.name == "R2.Scenario_1"
         assert rule2_scenario1.parent is rule2
         assert rule2_scenario1.feature is feature
         assert_compare_steps(rule2_scenario1.all_steps, [
             ("given", "Given", 'feature background step_1', None, None),
-            ("when", "When",   'feature background step_2', None, None),
+            ("when",  "When",  'feature background step_2', None, None),
             ("given", "Given", 'rule R2 scenario_1 step_1', None, None),
-            ("when", "When",   'rule R2 scenario_1 step_2', None, None),
+            ("when",  "When",  'rule R2 scenario_1 step_2', None, None),
+        ])
+
+
+# ---------------------------------------------------------------------------
+# TEST SUITE: Verify Feature Background to Rule Background Inheritance
+# ---------------------------------------------------------------------------
+class TestParser4Background(object):
+    """Verify feature.background to rule.background inheritance, etc."""
+
+    def test_parse__norule_scenarios_use_feature_background(self):
+        """AFFECTED: Scenarios outside of rules (before first rule)."""
+        text = u'''
+            Feature: With Scenarios and Rules
+            
+              Background: Feature.Background
+                Given feature background step_1
+            
+              Scenario: Scenario_1
+                Given scenario_1 step_1
+            
+              Rule: R1
+                Scenario: R1.Scenario_1
+                  Given rule R1 scenario_1 step_1
+            '''.lstrip()
+        feature = parse_feature(text)
+        assert feature.name == "With Scenarios and Rules"
+        assert feature.background is not None
+        assert len(feature.scenarios) == 1
+        assert len(feature.rules) == 1
+        assert len(feature.run_items) == 2
+
+        scenario1 = feature.scenarios[0]
+        rule1 = feature.rules[0]
+        assert feature.run_items == [scenario1, rule1]
+
+        assert scenario1.name == "Scenario_1"
+        assert scenario1.background is feature.background
+        assert scenario1.background_steps == feature.background.steps
+        assert_compare_steps(scenario1.all_steps, [
+            (u"given", u"Given", u'feature background step_1', None, None),
+            (u"given", u"Given", u'scenario_1 step_1', None, None),
+        ])
+
+    def test_parse__norule_scenarios_with_disabled_background(self):
+        """AFFECTED: Scenarios outside of rules (before first rule)."""
+        text = u'''
+            Feature: Scenario with disabled background
+            
+              Background: Feature.Background
+                Given feature background step_1
+            
+              @fixture.behave.disable_background
+              Scenario: Scenario_1
+                Given scenario_1 step_1
+            
+              Scenario: Scenario_2
+                Given scenario_2 step_1
+            '''.lstrip()
+        feature = parse_feature(text)
+        assert feature.name == "Scenario with disabled background"
+        assert feature.background is not None
+        assert len(feature.scenarios) == 2
+        assert len(feature.run_items) == 2
+
+        scenario1 = feature.scenarios[0]
+        scenario2 = feature.scenarios[1]
+        assert feature.run_items == [scenario1, scenario2]
+
+        scenario1.use_background = False    # -- FIXTURE-EFFECT (simulated)
+        assert scenario1.name == "Scenario_1"
+        assert scenario1.background is feature.background
+        assert scenario1.background_steps != feature.background.steps
+        assert scenario1.background_steps == []
+        assert_compare_steps(scenario1.all_steps, [
+            (u"given", u"Given", u'scenario_1 step_1', None, None),
+        ])
+
+        # -- ENSURE: Disabling of background has no effect on other scenarios.
+        assert scenario2.name == "Scenario_2"
+        assert scenario2.background is feature.background
+        assert scenario2.background_steps == feature.background.steps
+        assert_compare_steps(scenario2.all_steps, [
+            (u"given", u"Given", u'feature background step_1', None, None),
+            (u"given", u"Given", u'scenario_2 step_1', None, None),
+        ])
+
+    def test_parse__rule_scenarios_inherit_feature_background_without_rule_background(self):
+        text = u'''
+            Feature: With Background and Rule
+    
+              Background: Feature.Background
+                Given feature background step_1
+    
+              Rule: R1
+                Scenario: R1.Scenario_1
+                  Given rule R1 scenario_1 step_1
+            '''.lstrip()
+        feature = parse_feature(text)
+        assert feature.name == "With Background and Rule"
+        assert feature.background is not None
+        assert len(feature.scenarios) == 0
+        assert len(feature.rules) == 1
+        assert len(feature.run_items) == 1
+
+        rule1 = feature.rules[0]
+        rule1_scenario1 = rule1.scenarios[0]
+        assert feature.run_items == [rule1]
+
+        assert rule1_scenario1.name == "R1.Scenario_1"
+        assert rule1_scenario1.background is not None
+        # assert rule1_scenario1.background is not feature.background
+        assert rule1_scenario1.background_steps == feature.background.steps
+        assert_compare_steps(rule1_scenario1.all_steps, [
+            (u"given", u"Given", u'feature background step_1', None, None),
+            (u"given", u"Given", u'rule R1 scenario_1 step_1', None, None),
+        ])
+
+    def test_parse__rule_scenarios_inherit_feature_background_with_rule_background(self):
+        text = u'''
+            Feature: With Feature.Background and Rule.Background
+
+              Background: Feature.Background
+                Given feature background step_1
+
+              Rule: R1
+                Background: R1.Background
+                  Given rule R1 background step_1
+                
+                Scenario: R1.Scenario_1
+                  Given rule R1 scenario_1 step_1
+            '''.lstrip()
+        feature = parse_feature(text)
+        assert feature.name == "With Feature.Background and Rule.Background"
+        assert feature.background is not None
+        assert len(feature.scenarios) == 0
+        assert len(feature.rules) == 1
+        assert len(feature.run_items) == 1
+
+        rule1 = feature.rules[0]
+        rule1_scenario1 = rule1.scenarios[0]
+        assert feature.run_items == [rule1]
+
+        assert rule1.background is not None
+        assert rule1.background is not feature.background
+        assert rule1.background.inherited_steps == feature.background.steps
+        assert list(rule1.background.all_steps) != feature.background.steps
+
+        assert rule1_scenario1.name == "R1.Scenario_1"
+        assert rule1_scenario1.background is rule1.background
+        assert rule1_scenario1.background_steps == list(rule1.background.all_steps)
+        assert_compare_steps(rule1_scenario1.all_steps, [
+            (u"given", u"Given", u'feature background step_1', None, None),
+            (u"given", u"Given", u'rule R1 background step_1', None, None),
+            (u"given", u"Given", u'rule R1 scenario_1 step_1', None, None),
+        ])
+
+    def test_parse__rule_scenarios_with_rule_background_when_background_inheritance_is_disabled(self):
+        # -- HINT: Background inheritance is enabled (by default).
+        text = u'''
+            Feature: With Feature Background Inheritance disabled
+
+              Background: Feature.Background
+                Given feature background step_1
+
+              @fixture.behave.override_background
+              Rule: R1
+                Background: R1.Background
+                  Given rule R1 background step_1
+
+                Scenario: R1.Scenario_1
+                  Given rule R1 scenario_1 step_1
+            '''.lstrip()
+        feature = parse_feature(text)
+        assert feature.name == "With Feature Background Inheritance disabled"
+        assert feature.background is not None
+        assert len(feature.scenarios) == 0
+        assert len(feature.rules) == 1
+        assert len(feature.run_items) == 1
+
+        rule1 = feature.rules[0]
+        rule1_scenario1 = rule1.scenarios[0]
+        assert feature.run_items == [rule1]
+
+        rule1.use_background_inheritance = False  # FIXTURE-EFFECT (simulated)
+        assert rule1.background is not None
+        assert rule1.background.use_inheritance is False
+        assert rule1.background is not feature.background
+        assert rule1.background.inherited_steps == []
+        assert rule1.background.inherited_steps != feature.background.steps
+        assert list(rule1.background.all_steps) != feature.background.steps
+
+        assert rule1_scenario1.name == "R1.Scenario_1"
+        assert rule1_scenario1.background is rule1.background
+        assert rule1_scenario1.background_steps == rule1.background.steps
+        assert rule1_scenario1.background_steps == list(rule1.background.all_steps)
+        assert_compare_steps(rule1_scenario1.all_steps, [
+            (u"given", u"Given", u'rule R1 background step_1', None, None),
+            (u"given", u"Given", u'rule R1 scenario_1 step_1', None, None),
+        ])
+
+    def test_parse__rule_scenarios_without_rule_background_when_background_inheritance_is_disabled_without(self):
+        # -- HINT: Background inheritance is enabled (by default).
+        text = u'''
+            Feature: With Feature Background Inheritance disabled
+
+              Background: Feature.Background
+                Given feature background step_1
+
+              @fixture.behave.override_background
+              Rule: R1
+                Scenario: R1.Scenario_1
+                  Given rule R1 scenario_1 step_1
+            '''.lstrip()
+        feature = parse_feature(text)
+        assert feature.name == "With Feature Background Inheritance disabled"
+        assert feature.background is not None
+        assert len(feature.scenarios) == 0
+        assert len(feature.rules) == 1
+        assert len(feature.run_items) == 1
+
+        rule1 = feature.rules[0]
+        rule1_scenario1 = rule1.scenarios[0]
+        assert feature.run_items == [rule1]
+
+        rule1.use_background_inheritance = False  # FIXTURE-EFFECT (simulated)
+        assert rule1.background is not None
+        assert rule1.background.use_inheritance is False
+        assert rule1.background is not feature.background
+        assert rule1.background.inherited_steps == []
+
+        assert rule1_scenario1.name == "R1.Scenario_1"
+        assert rule1_scenario1.background is rule1.background
+        assert rule1_scenario1.background_steps == rule1.background.steps
+        assert rule1_scenario1.background_steps == list(rule1.background.all_steps)
+        assert_compare_steps(rule1_scenario1.all_steps, [
+            (u"given", u"Given", u'rule R1 scenario_1 step_1', None, None),
+        ])
+
+    def test_parse__rule_scenarios_without_feature_background_and_with_rule_background(self):
+        text = u'''
+            Feature: Without Feature.Background and with Rule.Background
+
+              Rule: R1
+                Background: R1.Background
+                  Given rule R1 background step_1
+
+                Scenario: R1.Scenario_1
+                  Given rule R1 scenario_1 step_1
+            '''.lstrip()
+        feature = parse_feature(text)
+        assert feature.name == "Without Feature.Background and with Rule.Background"
+        assert feature.background is None
+        assert len(feature.scenarios) == 0
+        assert len(feature.rules) == 1
+        assert len(feature.run_items) == 1
+
+        rule1 = feature.rules[0]
+        rule1_scenario1 = rule1.scenarios[0]
+        assert feature.run_items == [rule1]
+
+        assert rule1.background is not None
+        assert rule1.background is not feature.background
+        assert rule1.background.inherited_steps == []
+
+        assert rule1_scenario1.name == "R1.Scenario_1"
+        assert rule1_scenario1.background is rule1.background
+        assert rule1_scenario1.background_steps == rule1.background.steps
+        assert rule1_scenario1.background_steps == list(rule1.background.all_steps)
+        assert_compare_steps(rule1_scenario1.all_steps, [
+            (u"given", u"Given", u'rule R1 background step_1', None, None),
+            (u"given", u"Given", u'rule R1 scenario_1 step_1', None, None),
+        ])
+
+    def test_parse__rule_scenarios_without_feature_and_rule_background(self):
+        text = u'''
+            Feature: Without Feature.Background and Rule.Background
+
+              Rule: R1
+                Scenario: R1.Scenario_1
+                  Given rule R1 scenario_1 step_1
+            '''.lstrip()
+        feature = parse_feature(text)
+        assert feature.name == "Without Feature.Background and Rule.Background"
+        assert feature.background is None
+        assert len(feature.scenarios) == 0
+        assert len(feature.rules) == 1
+        assert len(feature.run_items) == 1
+
+        rule1 = feature.rules[0]
+        rule1_scenario1 = rule1.scenarios[0]
+        assert feature.run_items == [rule1]
+
+        assert rule1.background is None
+
+        assert rule1_scenario1.name == "R1.Scenario_1"
+        assert rule1_scenario1.background is None
+        assert rule1_scenario1.background is rule1.background
+        assert rule1_scenario1.background_steps == []
+        assert_compare_steps(rule1_scenario1.all_steps, [
+            (u"given", u"Given", u'rule R1 scenario_1 step_1', None, None),
         ])
 
 
