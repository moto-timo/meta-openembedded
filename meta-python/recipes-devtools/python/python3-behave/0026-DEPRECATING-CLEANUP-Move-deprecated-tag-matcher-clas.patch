From e828dbf79053891754e85ae90617e6207ce3f462 Mon Sep 17 00:00:00 2001
From: jenisys <jenisys@users.noreply.github.com>
Date: Sun, 9 Jun 2019 16:04:43 +0200
Subject: [PATCH] DEPRECATING-CLEANUP: Move deprecated tag matcher classes

- behave.tag_matcher.OnlyWithCategoryTagMatcher
- behave.tag_matcher.OnlyWithAnyCategoryTagMatcher

to "behave.attic.tag_matcher".
Move related unit tests to "tests.attic/unit/test_tag_matcher.py".
---
 behave/attic/__init__.py             |   0
 behave/attic/tag_matcher.py          | 181 +++++++++++++++++
 behave/tag_matcher.py                | 189 +-----------------
 tests.attic/__init__.py              |   0
 tests.attic/unit/__init__.py         |   0
 tests.attic/unit/test_tag_matcher.py | 280 +++++++++++++++++++++++++++
 tests/unit/test_tag_matcher.py       | 279 +-------------------------
 7 files changed, 470 insertions(+), 459 deletions(-)
 create mode 100644 behave/attic/__init__.py
 create mode 100644 behave/attic/tag_matcher.py
 create mode 100644 tests.attic/__init__.py
 create mode 100644 tests.attic/unit/__init__.py
 create mode 100644 tests.attic/unit/test_tag_matcher.py

diff --git a/behave/attic/__init__.py b/behave/attic/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/behave/attic/tag_matcher.py b/behave/attic/tag_matcher.py
new file mode 100644
index 0000000..f07dcbf
--- /dev/null
+++ b/behave/attic/tag_matcher.py
@@ -0,0 +1,181 @@
+# -----------------------------------------------------------------------------
+# PROTOTYPING CLASSES: Should no longer be used
+# -----------------------------------------------------------------------------
+
+import warnings
+from behave.tag_matcher import TagMatcher
+
+
+class OnlyWithCategoryTagMatcher(TagMatcher):
+    """
+    Provides a tag matcher that allows to determine if feature/scenario
+    should run or should be excluded from the run-set (at runtime).
+
+    .. deprecated:: Use :class:`ActiveTagMatcher` instead.
+
+    EXAMPLE:
+    --------
+
+    Run some scenarios only when runtime conditions are met:
+
+      * Run scenario Alice only on Windows OS
+      * Run scenario Bob only on MACOSX
+
+    .. code-block:: gherkin
+
+        # -- FILE: features/alice.feature
+        # TAG SCHEMA: @only.with_{category}={current_value}
+        Feature:
+
+          @only.with_os=win32
+          Scenario: Alice (Run only on Windows)
+            Given I do something
+            ...
+
+          @only.with_os=darwin
+          Scenario: Bob (Run only on MACOSX)
+            Given I do something else
+            ...
+
+
+    .. code-block:: python
+
+        # -- FILE: features/environment.py
+        from behave.tag_matcher import OnlyWithCategoryTagMatcher
+        import sys
+
+        # -- MATCHES TAGS: @only.with_{category}=* = @only.with_os=*
+        active_tag_matcher = OnlyWithCategoryTagMatcher("os", sys.platform)
+
+        def before_scenario(context, scenario):
+            if active_tag_matcher.should_exclude_with(scenario.effective_tags):
+                scenario.skip()   #< LATE-EXCLUDE from run-set.
+    """
+    tag_prefix = "only.with_"
+    value_separator = "="
+
+    def __init__(self, category, value, tag_prefix=None, value_sep=None):
+        warnings.warn("Use ActiveTagMatcher instead.", DeprecationWarning)
+        super(OnlyWithCategoryTagMatcher, self).__init__()
+        self.active_tag = self.make_category_tag(category, value,
+                                                 tag_prefix, value_sep)
+        self.category_tag_prefix = self.make_category_tag(category, None,
+                                                          tag_prefix, value_sep)
+
+    def should_exclude_with(self, tags):
+        category_tags = self.select_category_tags(tags)
+        if category_tags and self.active_tag not in category_tags:
+            return True
+        # -- OTHERWISE: feature/scenario with theses tags should run.
+        return False
+
+    def select_category_tags(self, tags):
+        return [tag  for tag in tags
+                if tag.startswith(self.category_tag_prefix)]
+
+    @classmethod
+    def make_category_tag(cls, category, value=None, tag_prefix=None,
+                          value_sep=None):
+        if tag_prefix is None:
+            tag_prefix = cls.tag_prefix
+        if value_sep is None:
+            value_sep = cls.value_separator
+        value = value or ""
+        return "%s%s%s%s" % (tag_prefix, category, value_sep, value)
+
+
+class OnlyWithAnyCategoryTagMatcher(TagMatcher):
+    """
+    Provides a tag matcher that matches any category that follows the
+    "@only.with_" tag schema and determines if it should run or
+    should be excluded from the run-set (at runtime).
+
+    TAG SCHEMA: @only.with_{category}={value}
+
+    .. seealso:: OnlyWithCategoryTagMatcher
+    .. deprecated:: Use :class:`ActiveTagMatcher` instead.
+
+    EXAMPLE:
+    --------
+
+    Run some scenarios only when runtime conditions are met:
+
+      * Run scenario Alice only on Windows OS
+      * Run scenario Bob only with browser Chrome
+
+    .. code-block:: gherkin
+
+        # -- FILE: features/alice.feature
+        # TAG SCHEMA: @only.with_{category}={current_value}
+        Feature:
+
+          @only.with_os=win32
+          Scenario: Alice (Run only on Windows)
+            Given I do something
+            ...
+
+          @only.with_browser=chrome
+          Scenario: Bob (Run only with Web-Browser Chrome)
+            Given I do something else
+            ...
+
+
+    .. code-block:: python
+
+        # -- FILE: features/environment.py
+        from behave.tag_matcher import OnlyWithAnyCategoryTagMatcher
+        import sys
+
+        # -- MATCHES ANY TAGS: @only.with_{category}={value}
+        # NOTE: active_tag_value_provider provides current category values.
+        active_tag_value_provider = {
+            "browser": os.environ.get("BEHAVE_BROWSER", "chrome"),
+            "os":      sys.platform,
+        }
+        active_tag_matcher = OnlyWithAnyCategoryTagMatcher(active_tag_value_provider)
+
+        def before_scenario(context, scenario):
+            if active_tag_matcher.should_exclude_with(scenario.effective_tags):
+                scenario.skip()   #< LATE-EXCLUDE from run-set.
+    """
+
+    def __init__(self, value_provider, tag_prefix=None, value_sep=None):
+        warnings.warn("Use ActiveTagMatcher instead.", DeprecationWarning)
+        super(OnlyWithAnyCategoryTagMatcher, self).__init__()
+        if value_sep is None:
+            value_sep = OnlyWithCategoryTagMatcher.value_separator
+        self.value_provider = value_provider
+        self.tag_prefix = tag_prefix or OnlyWithCategoryTagMatcher.tag_prefix
+        self.value_separator = value_sep
+
+    def should_exclude_with(self, tags):
+        exclude_decision_map = {}
+        for category_tag in self.select_category_tags(tags):
+            category, value = self.parse_category_tag(category_tag)
+            active_value = self.value_provider.get(category, None)
+            if active_value is None:
+                # -- CASE: Unknown category, ignore it.
+                continue
+            elif active_value == value:
+                # -- CASE: Active category value selected, decision should run.
+                exclude_decision_map[category] = False
+            else:
+                # -- CASE: Inactive category value selected, may exclude it.
+                if category not in exclude_decision_map:
+                    exclude_decision_map[category] = True
+        return any(exclude_decision_map.values())
+
+    def select_category_tags(self, tags):
+        return [tag  for tag in tags
+                if tag.startswith(self.tag_prefix)]
+
+    def parse_category_tag(self, tag):
+        assert tag and tag.startswith(self.tag_prefix)
+        category_value = tag[len(self.tag_prefix):]
+        if self.value_separator in category_value:
+            category, value = category_value.split(self.value_separator, 1)
+        else:
+            # -- OOPS: TAG SCHEMA FORMAT MISMATCH
+            category = category_value
+            value = None
+        return category, value
diff --git a/behave/tag_matcher.py b/behave/tag_matcher.py
index f1f955b..5f9dce0 100644
--- a/behave/tag_matcher.py
+++ b/behave/tag_matcher.py
@@ -1,9 +1,12 @@
-# -*- coding: utf-8 -*-
+# -*- coding: UTF-8 -*-
+"""
+Contains classes and functionality to provide a skip-if logic based on tags
+in feature files.
+"""
 
 from __future__ import absolute_import
 import re
 import operator
-import warnings
 import six
 
 
@@ -34,10 +37,10 @@ class ActiveTagMatcher(TagMatcher):
     """Provides an active tag matcher for many categories.
 
     TAG SCHEMA:
-      * active.with_{category}={value}
-      * not_active.with_{category}={value}
       * use.with_{category}={value}
       * not.with_{category}={value}
+      * active.with_{category}={value}
+      * not_active.with_{category}={value}
       * only.with_{category}={value}        (NOTE: For backward compatibility)
 
     TAG LOGIC
@@ -285,181 +288,3 @@ def setup_active_tag_values(active_tag_values, data):
     for category in list(active_tag_values.keys()):
         if category in data:
             active_tag_values[category] = data[category]
-
-
-# -----------------------------------------------------------------------------
-# PROTOTYPING CLASSES:
-# -----------------------------------------------------------------------------
-class OnlyWithCategoryTagMatcher(TagMatcher):
-    """
-    Provides a tag matcher that allows to determine if feature/scenario
-    should run or should be excluded from the run-set (at runtime).
-
-    .. deprecated:: Use :class:`ActiveTagMatcher` instead.
-
-    EXAMPLE:
-    --------
-
-    Run some scenarios only when runtime conditions are met:
-
-      * Run scenario Alice only on Windows OS
-      * Run scenario Bob only on MACOSX
-
-    .. code-block:: gherkin
-
-        # -- FILE: features/alice.feature
-        # TAG SCHEMA: @only.with_{category}={current_value}
-        Feature:
-
-          @only.with_os=win32
-          Scenario: Alice (Run only on Windows)
-            Given I do something
-            ...
-
-          @only.with_os=darwin
-          Scenario: Bob (Run only on MACOSX)
-            Given I do something else
-            ...
-
-
-    .. code-block:: python
-
-        # -- FILE: features/environment.py
-        from behave.tag_matcher import OnlyWithCategoryTagMatcher
-        import sys
-
-        # -- MATCHES TAGS: @only.with_{category}=* = @only.with_os=*
-        active_tag_matcher = OnlyWithCategoryTagMatcher("os", sys.platform)
-
-        def before_scenario(context, scenario):
-            if active_tag_matcher.should_exclude_with(scenario.effective_tags):
-                scenario.skip()   #< LATE-EXCLUDE from run-set.
-    """
-    tag_prefix = "only.with_"
-    value_separator = "="
-
-    def __init__(self, category, value, tag_prefix=None, value_sep=None):
-        warnings.warn("Use ActiveTagMatcher instead.", DeprecationWarning)
-        super(OnlyWithCategoryTagMatcher, self).__init__()
-        self.active_tag = self.make_category_tag(category, value,
-                                                 tag_prefix, value_sep)
-        self.category_tag_prefix = self.make_category_tag(category, None,
-                                                          tag_prefix, value_sep)
-
-    def should_exclude_with(self, tags):
-        category_tags = self.select_category_tags(tags)
-        if category_tags and self.active_tag not in category_tags:
-            return True
-        # -- OTHERWISE: feature/scenario with theses tags should run.
-        return False
-
-    def select_category_tags(self, tags):
-        return [tag  for tag in tags
-                if tag.startswith(self.category_tag_prefix)]
-
-    @classmethod
-    def make_category_tag(cls, category, value=None, tag_prefix=None,
-                          value_sep=None):
-        if tag_prefix is None:
-            tag_prefix = cls.tag_prefix
-        if value_sep is None:
-            value_sep = cls.value_separator
-        value = value or ""
-        return "%s%s%s%s" % (tag_prefix, category, value_sep, value)
-
-
-class OnlyWithAnyCategoryTagMatcher(TagMatcher):
-    """
-    Provides a tag matcher that matches any category that follows the
-    "@only.with_" tag schema and determines if it should run or
-    should be excluded from the run-set (at runtime).
-
-    TAG SCHEMA: @only.with_{category}={value}
-
-    .. seealso:: OnlyWithCategoryTagMatcher
-    .. deprecated:: Use :class:`ActiveTagMatcher` instead.
-
-    EXAMPLE:
-    --------
-
-    Run some scenarios only when runtime conditions are met:
-
-      * Run scenario Alice only on Windows OS
-      * Run scenario Bob only with browser Chrome
-
-    .. code-block:: gherkin
-
-        # -- FILE: features/alice.feature
-        # TAG SCHEMA: @only.with_{category}={current_value}
-        Feature:
-
-          @only.with_os=win32
-          Scenario: Alice (Run only on Windows)
-            Given I do something
-            ...
-
-          @only.with_browser=chrome
-          Scenario: Bob (Run only with Web-Browser Chrome)
-            Given I do something else
-            ...
-
-
-    .. code-block:: python
-
-        # -- FILE: features/environment.py
-        from behave.tag_matcher import OnlyWithAnyCategoryTagMatcher
-        import sys
-
-        # -- MATCHES ANY TAGS: @only.with_{category}={value}
-        # NOTE: active_tag_value_provider provides current category values.
-        active_tag_value_provider = {
-            "browser": os.environ.get("BEHAVE_BROWSER", "chrome"),
-            "os":      sys.platform,
-        }
-        active_tag_matcher = OnlyWithAnyCategoryTagMatcher(active_tag_value_provider)
-
-        def before_scenario(context, scenario):
-            if active_tag_matcher.should_exclude_with(scenario.effective_tags):
-                scenario.skip()   #< LATE-EXCLUDE from run-set.
-    """
-
-    def __init__(self, value_provider, tag_prefix=None, value_sep=None):
-        warnings.warn("Use ActiveTagMatcher instead.", DeprecationWarning)
-        super(OnlyWithAnyCategoryTagMatcher, self).__init__()
-        if value_sep is None:
-            value_sep = OnlyWithCategoryTagMatcher.value_separator
-        self.value_provider = value_provider
-        self.tag_prefix = tag_prefix or OnlyWithCategoryTagMatcher.tag_prefix
-        self.value_separator = value_sep
-
-    def should_exclude_with(self, tags):
-        exclude_decision_map = {}
-        for category_tag in self.select_category_tags(tags):
-            category, value = self.parse_category_tag(category_tag)
-            active_value = self.value_provider.get(category, None)
-            if active_value is None:
-                # -- CASE: Unknown category, ignore it.
-                continue
-            elif active_value == value:
-                # -- CASE: Active category value selected, decision should run.
-                exclude_decision_map[category] = False
-            else:
-                # -- CASE: Inactive category value selected, may exclude it.
-                if category not in exclude_decision_map:
-                    exclude_decision_map[category] = True
-        return any(exclude_decision_map.values())
-
-    def select_category_tags(self, tags):
-        return [tag  for tag in tags
-                if tag.startswith(self.tag_prefix)]
-
-    def parse_category_tag(self, tag):
-        assert tag and tag.startswith(self.tag_prefix)
-        category_value = tag[len(self.tag_prefix):]
-        if self.value_separator in category_value:
-            category, value = category_value.split(self.value_separator, 1)
-        else:
-            # -- OOPS: TAG SCHEMA FORMAT MISMATCH
-            category = category_value
-            value = None
-        return category, value
diff --git a/tests.attic/__init__.py b/tests.attic/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/tests.attic/unit/__init__.py b/tests.attic/unit/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/tests.attic/unit/test_tag_matcher.py b/tests.attic/unit/test_tag_matcher.py
new file mode 100644
index 0000000..d767fa7
--- /dev/null
+++ b/tests.attic/unit/test_tag_matcher.py
@@ -0,0 +1,280 @@
+# -----------------------------------------------------------------------------
+# PROTOTYPING CLASSES (deprecating) -- Should no longer be used.
+# -----------------------------------------------------------------------------
+
+import warnings
+from unittest import TestCase
+from behave.attic.tag_matcher import \
+    OnlyWithCategoryTagMatcher,  OnlyWithAnyCategoryTagMatcher
+
+
+class TestOnlyWithCategoryTagMatcher(TestCase):
+    TagMatcher = OnlyWithCategoryTagMatcher
+
+    def setUp(self):
+        category = "xxx"
+        with warnings.catch_warnings():
+            warnings.simplefilter("ignore", DeprecationWarning)
+            self.tag_matcher = OnlyWithCategoryTagMatcher(category, "alice")
+        self.enabled_tag = self.TagMatcher.make_category_tag(category, "alice")
+        self.similar_tag = self.TagMatcher.make_category_tag(category, "alice2")
+        self.other_tag = self.TagMatcher.make_category_tag(category, "other")
+        self.category = category
+
+    def test_should_exclude_with__returns_false_with_enabled_tag(self):
+        tags = [ self.enabled_tag ]
+        self.assertEqual(False, self.tag_matcher.should_exclude_with(tags))
+
+    def test_should_exclude_with__returns_false_with_enabled_tag_and_more(self):
+        test_patterns = [
+            ([ self.enabled_tag, self.other_tag ], "case: first"),
+            ([ self.other_tag, self.enabled_tag ], "case: last"),
+            ([ "foo", self.enabled_tag, self.other_tag, "bar" ], "case: middle"),
+        ]
+        for tags, case in test_patterns:
+            self.assertEqual(False, self.tag_matcher.should_exclude_with(tags),
+                             "%s: tags=%s" % (case, tags))
+
+    def test_should_exclude_with__returns_true_with_other_tag(self):
+        tags = [ self.other_tag ]
+        self.assertEqual(True, self.tag_matcher.should_exclude_with(tags))
+
+    def test_should_exclude_with__returns_true_with_other_tag_and_more(self):
+        test_patterns = [
+            ([ self.other_tag, "foo" ], "case: first"),
+            ([ "foo", self.other_tag ], "case: last"),
+            ([ "foo", self.other_tag, "bar" ], "case: middle"),
+        ]
+        for tags, case in test_patterns:
+            self.assertEqual(True, self.tag_matcher.should_exclude_with(tags),
+                             "%s: tags=%s" % (case, tags))
+
+    def test_should_exclude_with__returns_true_with_similar_tag(self):
+        tags = [ self.similar_tag ]
+        self.assertEqual(True, self.tag_matcher.should_exclude_with(tags))
+
+    def test_should_exclude_with__returns_true_with_similar_and_more(self):
+        test_patterns = [
+            ([ self.similar_tag, "foo" ], "case: first"),
+            ([ "foo", self.similar_tag ], "case: last"),
+            ([ "foo", self.similar_tag, "bar" ], "case: middle"),
+        ]
+        for tags, case in test_patterns:
+            self.assertEqual(True, self.tag_matcher.should_exclude_with(tags),
+                             "%s: tags=%s" % (case, tags))
+
+    def test_should_exclude_with__returns_false_without_category_tag(self):
+        test_patterns = [
+            ([ ],           "case: No tags"),
+            ([ "foo" ],     "case: One tag"),
+            ([ "foo", "bar" ], "case: Two tags"),
+        ]
+        for tags, case in test_patterns:
+            self.assertEqual(False, self.tag_matcher.should_exclude_with(tags),
+                             "%s: tags=%s" % (case, tags))
+
+    def test_should_run_with__negates_result_of_should_exclude_with(self):
+        test_patterns = [
+            ([ ],                   "case: No tags"),
+            ([ "foo" ],             "case: One non-category tag"),
+            ([ "foo", "bar" ],      "case: Two non-category tags"),
+            ([ self.enabled_tag ],   "case: enabled tag"),
+            ([ self.enabled_tag, self.other_tag ],  "case: enabled and other tag"),
+            ([ self.enabled_tag, "foo" ],    "case: enabled and foo tag"),
+            ([ self.other_tag ],            "case: other tag"),
+            ([ self.other_tag, "foo" ],     "case: other and foo tag"),
+            ([ self.similar_tag ],          "case: similar tag"),
+            ([ "foo", self.similar_tag ],   "case: foo and similar tag"),
+        ]
+        for tags, case in test_patterns:
+            result1 = self.tag_matcher.should_run_with(tags)
+            result2 = self.tag_matcher.should_exclude_with(tags)
+            self.assertEqual(result1, not result2, "%s: tags=%s" % (case, tags))
+            self.assertEqual(not result1, result2, "%s: tags=%s" % (case, tags))
+
+    def test_make_category_tag__returns_category_tag_prefix_without_value(self):
+        category = "xxx"
+        tag1 = OnlyWithCategoryTagMatcher.make_category_tag(category)
+        tag2 = OnlyWithCategoryTagMatcher.make_category_tag(category, None)
+        tag3 = OnlyWithCategoryTagMatcher.make_category_tag(category, value=None)
+        self.assertEqual("only.with_xxx=", tag1)
+        self.assertEqual("only.with_xxx=", tag2)
+        self.assertEqual("only.with_xxx=", tag3)
+        self.assertTrue(tag1.startswith(OnlyWithCategoryTagMatcher.tag_prefix))
+
+    def test_make_category_tag__returns_category_tag_with_value(self):
+        category = "xxx"
+        tag1 = OnlyWithCategoryTagMatcher.make_category_tag(category, "alice")
+        tag2 = OnlyWithCategoryTagMatcher.make_category_tag(category, "bob")
+        self.assertEqual("only.with_xxx=alice", tag1)
+        self.assertEqual("only.with_xxx=bob", tag2)
+
+    def test_make_category_tag__returns_category_tag_with_tag_prefix(self):
+        my_tag_prefix = "ONLY_WITH."
+        category = "xxx"
+        TagMatcher = OnlyWithCategoryTagMatcher
+        tag0 = TagMatcher.make_category_tag(category, tag_prefix=my_tag_prefix)
+        tag1 = TagMatcher.make_category_tag(category, "alice", my_tag_prefix)
+        tag2 = TagMatcher.make_category_tag(category, "bob", tag_prefix=my_tag_prefix)
+        self.assertEqual("ONLY_WITH.xxx=", tag0)
+        self.assertEqual("ONLY_WITH.xxx=alice", tag1)
+        self.assertEqual("ONLY_WITH.xxx=bob", tag2)
+        self.assertTrue(tag1.startswith(my_tag_prefix))
+
+    def test_ctor__with_tag_prefix(self):
+        tag_prefix = "ONLY_WITH."
+        tag_matcher = OnlyWithCategoryTagMatcher("xxx", "alice", tag_prefix)
+
+        tags = ["foo", "ONLY_WITH.xxx=foo", "only.with_xxx=bar", "bar"]
+        actual_tags = tag_matcher.select_category_tags(tags)
+        self.assertEqual(["ONLY_WITH.xxx=foo"], actual_tags)
+
+
+class Traits4OnlyWithAnyCategoryTagMatcher(object):
+    """Test data for OnlyWithAnyCategoryTagMatcher."""
+
+    TagMatcher0 = OnlyWithCategoryTagMatcher
+    TagMatcher = OnlyWithAnyCategoryTagMatcher
+    category1_enabled_tag = TagMatcher0.make_category_tag("foo", "alice")
+    category1_similar_tag = TagMatcher0.make_category_tag("foo", "alice2")
+    category1_disabled_tag = TagMatcher0.make_category_tag("foo", "bob")
+    category2_enabled_tag = TagMatcher0.make_category_tag("bar", "BOB")
+    category2_similar_tag = TagMatcher0.make_category_tag("bar", "BOB2")
+    category2_disabled_tag = TagMatcher0.make_category_tag("bar", "CHARLY")
+    unknown_category_tag = TagMatcher0.make_category_tag("UNKNOWN", "one")
+
+
+class TestOnlyWithAnyCategoryTagMatcher(TestCase):
+    TagMatcher = OnlyWithAnyCategoryTagMatcher
+    traits = Traits4OnlyWithAnyCategoryTagMatcher
+
+    def setUp(self):
+        value_provider = {
+            "foo": "alice",
+            "bar": "BOB",
+        }
+        with warnings.catch_warnings():
+            warnings.simplefilter("ignore", DeprecationWarning)
+            self.tag_matcher = self.TagMatcher(value_provider)
+
+    # def test_deprecating_warning_is_issued(self):
+    #     value_provider = {"foo": "alice"}
+    #     with warnings.catch_warnings(record=True) as recorder:
+    #         warnings.simplefilter("always", DeprecationWarning)
+    #         tag_matcher = OnlyWithAnyCategoryTagMatcher(value_provider)
+    #         self.assertEqual(len(recorder), 1)
+    #         last_warning = recorder[-1]
+    #         assert issubclass(last_warning.category, DeprecationWarning)
+    #         assert "deprecated" in str(last_warning.message)
+
+    def test_should_exclude_with__returns_false_with_enabled_tag(self):
+        traits = self.traits
+        tags1 = [ traits.category1_enabled_tag ]
+        tags2 = [ traits.category2_enabled_tag ]
+        self.assertEqual(False, self.tag_matcher.should_exclude_with(tags1))
+        self.assertEqual(False, self.tag_matcher.should_exclude_with(tags2))
+
+    def test_should_exclude_with__returns_false_with_enabled_tag_and_more(self):
+        traits = self.traits
+        test_patterns = [
+            ([ traits.category1_enabled_tag, traits.category1_disabled_tag ], "case: first"),
+            ([ traits.category1_disabled_tag, traits.category1_enabled_tag ], "case: last"),
+            ([ "foo", traits.category1_enabled_tag, traits.category1_disabled_tag, "bar" ], "case: middle"),
+        ]
+        for tags, case in test_patterns:
+            self.assertEqual(False, self.tag_matcher.should_exclude_with(tags),
+                             "%s: tags=%s" % (case, tags))
+
+    def test_should_exclude_with__returns_true_with_other_tag(self):
+        traits = self.traits
+        tags = [ traits.category1_disabled_tag ]
+        self.assertEqual(True, self.tag_matcher.should_exclude_with(tags))
+
+    def test_should_exclude_with__returns_true_with_other_tag_and_more(self):
+        traits = self.traits
+        test_patterns = [
+            ([ traits.category1_disabled_tag, "foo" ], "case: first"),
+            ([ "foo", traits.category1_disabled_tag ], "case: last"),
+            ([ "foo", traits.category1_disabled_tag, "bar" ], "case: middle"),
+        ]
+        for tags, case in test_patterns:
+            self.assertEqual(True, self.tag_matcher.should_exclude_with(tags),
+                             "%s: tags=%s" % (case, tags))
+
+    def test_should_exclude_with__returns_true_with_similar_tag(self):
+        traits = self.traits
+        tags = [ traits.category1_similar_tag ]
+        self.assertEqual(True, self.tag_matcher.should_exclude_with(tags))
+
+    def test_should_exclude_with__returns_true_with_similar_and_more(self):
+        traits = self.traits
+        test_patterns = [
+            ([ traits.category1_similar_tag, "foo" ], "case: first"),
+            ([ "foo", traits.category1_similar_tag ], "case: last"),
+            ([ "foo", traits.category1_similar_tag, "bar" ], "case: middle"),
+        ]
+        for tags, case in test_patterns:
+            self.assertEqual(True, self.tag_matcher.should_exclude_with(tags),
+                             "%s: tags=%s" % (case, tags))
+
+    def test_should_exclude_with__returns_false_without_category_tag(self):
+        test_patterns = [
+            ([ ],           "case: No tags"),
+            ([ "foo" ],     "case: One tag"),
+            ([ "foo", "bar" ], "case: Two tags"),
+        ]
+        for tags, case in test_patterns:
+            self.assertEqual(False, self.tag_matcher.should_exclude_with(tags),
+                             "%s: tags=%s" % (case, tags))
+
+    def test_should_exclude_with__returns_false_with_unknown_category_tag(self):
+        """Tags from unknown categories, not supported by value_provider,
+        should not be excluded.
+        """
+        traits = self.traits
+        tags = [ traits.unknown_category_tag ]
+        self.assertEqual("only.with_UNKNOWN=one", traits.unknown_category_tag)
+        self.assertEqual(None, self.tag_matcher.value_provider.get("UNKNOWN"))
+        self.assertEqual(False, self.tag_matcher.should_exclude_with(tags))
+
+    def test_should_exclude_with__combinations_of_2_categories(self):
+        traits = self.traits
+        test_patterns = [
+            ("case 00: 2 disabled category tags", True,
+             [ traits.category1_disabled_tag, traits.category2_disabled_tag]),
+            ("case 01: disabled and enabled category tags", True,
+             [ traits.category1_disabled_tag, traits.category2_enabled_tag]),
+            ("case 10: enabled and disabled category tags", True,
+             [ traits.category1_enabled_tag, traits.category2_disabled_tag]),
+            ("case 11: 2 enabled category tags", False,  # -- SHOULD-RUN
+             [ traits.category1_enabled_tag, traits.category2_enabled_tag]),
+            # -- SPECIAL CASE: With unknown category
+            ("case 0x: disabled and unknown category tags", True,
+             [ traits.category1_disabled_tag, traits.unknown_category_tag]),
+            ("case 1x: enabled and unknown category tags", False,  # SHOULD-RUN
+             [ traits.category1_enabled_tag, traits.unknown_category_tag]),
+        ]
+        for case, expected, tags in test_patterns:
+            actual_result = self.tag_matcher.should_exclude_with(tags)
+            self.assertEqual(expected, actual_result,
+                             "%s: tags=%s" % (case, tags))
+
+    def test_should_run_with__negates_result_of_should_exclude_with(self):
+        traits = self.traits
+        test_patterns = [
+            ([ ],                   "case: No tags"),
+            ([ "foo" ],             "case: One non-category tag"),
+            ([ "foo", "bar" ],      "case: Two non-category tags"),
+            ([ traits.category1_enabled_tag ],   "case: enabled tag"),
+            ([ traits.category1_enabled_tag, traits.category1_disabled_tag ],  "case: enabled and other tag"),
+            ([ traits.category1_enabled_tag, "foo" ],    "case: enabled and foo tag"),
+            ([ traits.category1_disabled_tag ],            "case: other tag"),
+            ([ traits.category1_disabled_tag, "foo" ],     "case: other and foo tag"),
+            ([ traits.category1_similar_tag ],          "case: similar tag"),
+            ([ "foo", traits.category1_similar_tag ],   "case: foo and similar tag"),
+        ]
+        for tags, case in test_patterns:
+            result1 = self.tag_matcher.should_run_with(tags)
+            result2 = self.tag_matcher.should_exclude_with(tags)
+            self.assertEqual(result1, not result2, "%s: tags=%s" % (case, tags))
+            self.assertEqual(not result1, result2, "%s: tags=%s" % (case, tags))
diff --git a/tests/unit/test_tag_matcher.py b/tests/unit/test_tag_matcher.py
index c5d2266..a04c1d4 100644
--- a/tests/unit/test_tag_matcher.py
+++ b/tests/unit/test_tag_matcher.py
@@ -8,12 +8,13 @@ Unit tests for active tag-matcher (mod:`behave.tag_matcher`).
 """
 
 from __future__ import absolute_import
-from behave.tag_matcher import *
 from mock import Mock
 from unittest import TestCase
 import warnings
 import pytest
 
+from behave.tag_matcher import *
+
 
 class Traits4ActiveTagMatcher(object):
     TagMatcher = ActiveTagMatcher
@@ -460,279 +461,3 @@ class TestCompositeTagMatcher(TestCase):
             actual_true_count = self.count_tag_matcher_with_result(
                                     self.ctag_matcher.tag_matchers, tags, True)
             self.assertEqual(0, actual_true_count)
-
-
-# -----------------------------------------------------------------------------
-# PROTOTYPING CLASSES (deprecating)
-# -----------------------------------------------------------------------------
-class TestOnlyWithCategoryTagMatcher(TestCase):
-    TagMatcher = OnlyWithCategoryTagMatcher
-
-    def setUp(self):
-        category = "xxx"
-        with warnings.catch_warnings():
-            warnings.simplefilter("ignore", DeprecationWarning)
-            self.tag_matcher = OnlyWithCategoryTagMatcher(category, "alice")
-        self.enabled_tag = self.TagMatcher.make_category_tag(category, "alice")
-        self.similar_tag = self.TagMatcher.make_category_tag(category, "alice2")
-        self.other_tag = self.TagMatcher.make_category_tag(category, "other")
-        self.category = category
-
-    def test_should_exclude_with__returns_false_with_enabled_tag(self):
-        tags = [ self.enabled_tag ]
-        self.assertEqual(False, self.tag_matcher.should_exclude_with(tags))
-
-    def test_should_exclude_with__returns_false_with_enabled_tag_and_more(self):
-        test_patterns = [
-            ([ self.enabled_tag, self.other_tag ], "case: first"),
-            ([ self.other_tag, self.enabled_tag ], "case: last"),
-            ([ "foo", self.enabled_tag, self.other_tag, "bar" ], "case: middle"),
-        ]
-        for tags, case in test_patterns:
-            self.assertEqual(False, self.tag_matcher.should_exclude_with(tags),
-                             "%s: tags=%s" % (case, tags))
-
-    def test_should_exclude_with__returns_true_with_other_tag(self):
-        tags = [ self.other_tag ]
-        self.assertEqual(True, self.tag_matcher.should_exclude_with(tags))
-
-    def test_should_exclude_with__returns_true_with_other_tag_and_more(self):
-        test_patterns = [
-            ([ self.other_tag, "foo" ], "case: first"),
-            ([ "foo", self.other_tag ], "case: last"),
-            ([ "foo", self.other_tag, "bar" ], "case: middle"),
-        ]
-        for tags, case in test_patterns:
-            self.assertEqual(True, self.tag_matcher.should_exclude_with(tags),
-                             "%s: tags=%s" % (case, tags))
-
-    def test_should_exclude_with__returns_true_with_similar_tag(self):
-        tags = [ self.similar_tag ]
-        self.assertEqual(True, self.tag_matcher.should_exclude_with(tags))
-
-    def test_should_exclude_with__returns_true_with_similar_and_more(self):
-        test_patterns = [
-            ([ self.similar_tag, "foo" ], "case: first"),
-            ([ "foo", self.similar_tag ], "case: last"),
-            ([ "foo", self.similar_tag, "bar" ], "case: middle"),
-        ]
-        for tags, case in test_patterns:
-            self.assertEqual(True, self.tag_matcher.should_exclude_with(tags),
-                             "%s: tags=%s" % (case, tags))
-
-    def test_should_exclude_with__returns_false_without_category_tag(self):
-        test_patterns = [
-            ([ ],           "case: No tags"),
-            ([ "foo" ],     "case: One tag"),
-            ([ "foo", "bar" ], "case: Two tags"),
-        ]
-        for tags, case in test_patterns:
-            self.assertEqual(False, self.tag_matcher.should_exclude_with(tags),
-                             "%s: tags=%s" % (case, tags))
-
-    def test_should_run_with__negates_result_of_should_exclude_with(self):
-        test_patterns = [
-            ([ ],                   "case: No tags"),
-            ([ "foo" ],             "case: One non-category tag"),
-            ([ "foo", "bar" ],      "case: Two non-category tags"),
-            ([ self.enabled_tag ],   "case: enabled tag"),
-            ([ self.enabled_tag, self.other_tag ],  "case: enabled and other tag"),
-            ([ self.enabled_tag, "foo" ],    "case: enabled and foo tag"),
-            ([ self.other_tag ],            "case: other tag"),
-            ([ self.other_tag, "foo" ],     "case: other and foo tag"),
-            ([ self.similar_tag ],          "case: similar tag"),
-            ([ "foo", self.similar_tag ],   "case: foo and similar tag"),
-        ]
-        for tags, case in test_patterns:
-            result1 = self.tag_matcher.should_run_with(tags)
-            result2 = self.tag_matcher.should_exclude_with(tags)
-            self.assertEqual(result1, not result2, "%s: tags=%s" % (case, tags))
-            self.assertEqual(not result1, result2, "%s: tags=%s" % (case, tags))
-
-    def test_make_category_tag__returns_category_tag_prefix_without_value(self):
-        category = "xxx"
-        tag1 = OnlyWithCategoryTagMatcher.make_category_tag(category)
-        tag2 = OnlyWithCategoryTagMatcher.make_category_tag(category, None)
-        tag3 = OnlyWithCategoryTagMatcher.make_category_tag(category, value=None)
-        self.assertEqual("only.with_xxx=", tag1)
-        self.assertEqual("only.with_xxx=", tag2)
-        self.assertEqual("only.with_xxx=", tag3)
-        self.assertTrue(tag1.startswith(OnlyWithCategoryTagMatcher.tag_prefix))
-
-    def test_make_category_tag__returns_category_tag_with_value(self):
-        category = "xxx"
-        tag1 = OnlyWithCategoryTagMatcher.make_category_tag(category, "alice")
-        tag2 = OnlyWithCategoryTagMatcher.make_category_tag(category, "bob")
-        self.assertEqual("only.with_xxx=alice", tag1)
-        self.assertEqual("only.with_xxx=bob", tag2)
-
-    def test_make_category_tag__returns_category_tag_with_tag_prefix(self):
-        my_tag_prefix = "ONLY_WITH."
-        category = "xxx"
-        TagMatcher = OnlyWithCategoryTagMatcher
-        tag0 = TagMatcher.make_category_tag(category, tag_prefix=my_tag_prefix)
-        tag1 = TagMatcher.make_category_tag(category, "alice", my_tag_prefix)
-        tag2 = TagMatcher.make_category_tag(category, "bob", tag_prefix=my_tag_prefix)
-        self.assertEqual("ONLY_WITH.xxx=", tag0)
-        self.assertEqual("ONLY_WITH.xxx=alice", tag1)
-        self.assertEqual("ONLY_WITH.xxx=bob", tag2)
-        self.assertTrue(tag1.startswith(my_tag_prefix))
-
-    def test_ctor__with_tag_prefix(self):
-        tag_prefix = "ONLY_WITH."
-        tag_matcher = OnlyWithCategoryTagMatcher("xxx", "alice", tag_prefix)
-
-        tags = ["foo", "ONLY_WITH.xxx=foo", "only.with_xxx=bar", "bar"]
-        actual_tags = tag_matcher.select_category_tags(tags)
-        self.assertEqual(["ONLY_WITH.xxx=foo"], actual_tags)
-
-
-class Traits4OnlyWithAnyCategoryTagMatcher(object):
-    """Test data for OnlyWithAnyCategoryTagMatcher."""
-
-    TagMatcher0 = OnlyWithCategoryTagMatcher
-    TagMatcher = OnlyWithAnyCategoryTagMatcher
-    category1_enabled_tag = TagMatcher0.make_category_tag("foo", "alice")
-    category1_similar_tag = TagMatcher0.make_category_tag("foo", "alice2")
-    category1_disabled_tag = TagMatcher0.make_category_tag("foo", "bob")
-    category2_enabled_tag = TagMatcher0.make_category_tag("bar", "BOB")
-    category2_similar_tag = TagMatcher0.make_category_tag("bar", "BOB2")
-    category2_disabled_tag = TagMatcher0.make_category_tag("bar", "CHARLY")
-    unknown_category_tag = TagMatcher0.make_category_tag("UNKNOWN", "one")
-
-
-class TestOnlyWithAnyCategoryTagMatcher(TestCase):
-    TagMatcher = OnlyWithAnyCategoryTagMatcher
-    traits = Traits4OnlyWithAnyCategoryTagMatcher
-
-    def setUp(self):
-        value_provider = {
-            "foo": "alice",
-            "bar": "BOB",
-        }
-        with warnings.catch_warnings():
-            warnings.simplefilter("ignore", DeprecationWarning)
-            self.tag_matcher = self.TagMatcher(value_provider)
-
-    # def test_deprecating_warning_is_issued(self):
-    #     value_provider = {"foo": "alice"}
-    #     with warnings.catch_warnings(record=True) as recorder:
-    #         warnings.simplefilter("always", DeprecationWarning)
-    #         tag_matcher = OnlyWithAnyCategoryTagMatcher(value_provider)
-    #         self.assertEqual(len(recorder), 1)
-    #         last_warning = recorder[-1]
-    #         assert issubclass(last_warning.category, DeprecationWarning)
-    #         assert "deprecated" in str(last_warning.message)
-
-    def test_should_exclude_with__returns_false_with_enabled_tag(self):
-        traits = self.traits
-        tags1 = [ traits.category1_enabled_tag ]
-        tags2 = [ traits.category2_enabled_tag ]
-        self.assertEqual(False, self.tag_matcher.should_exclude_with(tags1))
-        self.assertEqual(False, self.tag_matcher.should_exclude_with(tags2))
-
-    def test_should_exclude_with__returns_false_with_enabled_tag_and_more(self):
-        traits = self.traits
-        test_patterns = [
-            ([ traits.category1_enabled_tag, traits.category1_disabled_tag ], "case: first"),
-            ([ traits.category1_disabled_tag, traits.category1_enabled_tag ], "case: last"),
-            ([ "foo", traits.category1_enabled_tag, traits.category1_disabled_tag, "bar" ], "case: middle"),
-        ]
-        for tags, case in test_patterns:
-            self.assertEqual(False, self.tag_matcher.should_exclude_with(tags),
-                             "%s: tags=%s" % (case, tags))
-
-    def test_should_exclude_with__returns_true_with_other_tag(self):
-        traits = self.traits
-        tags = [ traits.category1_disabled_tag ]
-        self.assertEqual(True, self.tag_matcher.should_exclude_with(tags))
-
-    def test_should_exclude_with__returns_true_with_other_tag_and_more(self):
-        traits = self.traits
-        test_patterns = [
-            ([ traits.category1_disabled_tag, "foo" ], "case: first"),
-            ([ "foo", traits.category1_disabled_tag ], "case: last"),
-            ([ "foo", traits.category1_disabled_tag, "bar" ], "case: middle"),
-        ]
-        for tags, case in test_patterns:
-            self.assertEqual(True, self.tag_matcher.should_exclude_with(tags),
-                             "%s: tags=%s" % (case, tags))
-
-    def test_should_exclude_with__returns_true_with_similar_tag(self):
-        traits = self.traits
-        tags = [ traits.category1_similar_tag ]
-        self.assertEqual(True, self.tag_matcher.should_exclude_with(tags))
-
-    def test_should_exclude_with__returns_true_with_similar_and_more(self):
-        traits = self.traits
-        test_patterns = [
-            ([ traits.category1_similar_tag, "foo" ], "case: first"),
-            ([ "foo", traits.category1_similar_tag ], "case: last"),
-            ([ "foo", traits.category1_similar_tag, "bar" ], "case: middle"),
-        ]
-        for tags, case in test_patterns:
-            self.assertEqual(True, self.tag_matcher.should_exclude_with(tags),
-                             "%s: tags=%s" % (case, tags))
-
-    def test_should_exclude_with__returns_false_without_category_tag(self):
-        test_patterns = [
-            ([ ],           "case: No tags"),
-            ([ "foo" ],     "case: One tag"),
-            ([ "foo", "bar" ], "case: Two tags"),
-        ]
-        for tags, case in test_patterns:
-            self.assertEqual(False, self.tag_matcher.should_exclude_with(tags),
-                             "%s: tags=%s" % (case, tags))
-
-    def test_should_exclude_with__returns_false_with_unknown_category_tag(self):
-        """Tags from unknown categories, not supported by value_provider,
-        should not be excluded.
-        """
-        traits = self.traits
-        tags = [ traits.unknown_category_tag ]
-        self.assertEqual("only.with_UNKNOWN=one", traits.unknown_category_tag)
-        self.assertEqual(None, self.tag_matcher.value_provider.get("UNKNOWN"))
-        self.assertEqual(False, self.tag_matcher.should_exclude_with(tags))
-
-    def test_should_exclude_with__combinations_of_2_categories(self):
-        traits = self.traits
-        test_patterns = [
-            ("case 00: 2 disabled category tags", True,
-             [ traits.category1_disabled_tag, traits.category2_disabled_tag]),
-            ("case 01: disabled and enabled category tags", True,
-             [ traits.category1_disabled_tag, traits.category2_enabled_tag]),
-            ("case 10: enabled and disabled category tags", True,
-             [ traits.category1_enabled_tag, traits.category2_disabled_tag]),
-            ("case 11: 2 enabled category tags", False,  # -- SHOULD-RUN
-             [ traits.category1_enabled_tag, traits.category2_enabled_tag]),
-            # -- SPECIAL CASE: With unknown category
-            ("case 0x: disabled and unknown category tags", True,
-             [ traits.category1_disabled_tag, traits.unknown_category_tag]),
-            ("case 1x: enabled and unknown category tags", False,  # SHOULD-RUN
-             [ traits.category1_enabled_tag, traits.unknown_category_tag]),
-        ]
-        for case, expected, tags in test_patterns:
-            actual_result = self.tag_matcher.should_exclude_with(tags)
-            self.assertEqual(expected, actual_result,
-                             "%s: tags=%s" % (case, tags))
-
-    def test_should_run_with__negates_result_of_should_exclude_with(self):
-        traits = self.traits
-        test_patterns = [
-            ([ ],                   "case: No tags"),
-            ([ "foo" ],             "case: One non-category tag"),
-            ([ "foo", "bar" ],      "case: Two non-category tags"),
-            ([ traits.category1_enabled_tag ],   "case: enabled tag"),
-            ([ traits.category1_enabled_tag, traits.category1_disabled_tag ],  "case: enabled and other tag"),
-            ([ traits.category1_enabled_tag, "foo" ],    "case: enabled and foo tag"),
-            ([ traits.category1_disabled_tag ],            "case: other tag"),
-            ([ traits.category1_disabled_tag, "foo" ],     "case: other and foo tag"),
-            ([ traits.category1_similar_tag ],          "case: similar tag"),
-            ([ "foo", traits.category1_similar_tag ],   "case: foo and similar tag"),
-        ]
-        for tags, case in test_patterns:
-            result1 = self.tag_matcher.should_run_with(tags)
-            result2 = self.tag_matcher.should_exclude_with(tags)
-            self.assertEqual(result1, not result2, "%s: tags=%s" % (case, tags))
-            self.assertEqual(not result1, result2, "%s: tags=%s" % (case, tags))
-
