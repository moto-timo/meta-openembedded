From da8ed4b628c23e7e28c642a3ed3d848009d423c1 Mon Sep 17 00:00:00 2001
From: jenisys <jenisys@users.noreply.github.com>
Date: Sat, 9 Jan 2021 22:04:18 +0100
Subject: [PATCH] FIX: Active-tag logic

Fix active-tag computation logic if multiple active-tags exist
that use the same category. It is now possible to use
positive (use.with_xxx) and negative (not.with_xxx) tags
on the same model element (Feature, Scenario, ...).
---
 behave/api/runtime_constraint.py     |  12 +-
 behave/tag_matcher.py                |  82 ++++-
 features/tags.active_tags.feature    |  22 +-
 tests/functional/test_active_tags.py | 529 +++++++++++++++++++++++++++
 tests/unit/test_tag_matcher.py       |  45 +--
 5 files changed, 624 insertions(+), 66 deletions(-)
 create mode 100644 tests/functional/test_active_tags.py

diff --git a/behave/api/runtime_constraint.py b/behave/api/runtime_constraint.py
index 310e529..e5a36a0 100644
--- a/behave/api/runtime_constraint.py
+++ b/behave/api/runtime_constraint.py
@@ -7,6 +7,8 @@ Simplifies to specify runtime constraints in
 """
 
 from __future__ import absolute_import
+import six
+import sys
 from behave.exception import ConstraintError
 
 
@@ -19,11 +21,10 @@ def require_min_python_version(minimal_version):
     :param minimal_version: Minimum version (as string, tuple)
     :raises: behave.exception.ConstraintError
     """
-    import six
-    import sys
     python_version = sys.version_info
     if isinstance(minimal_version, six.string_types):
-        python_version = "%s.%s" % sys.version_info[:2]
+        python_version = float("%s.%s" % sys.version_info[:2])
+        minimal_version = float(minimal_version)
     elif not isinstance(minimal_version, tuple):
         raise TypeError("string or tuple (was: %s)" % type(minimal_version))
 
@@ -40,6 +41,9 @@ def require_min_behave_version(minimal_version):
     """
     # -- SIMPLISTIC IMPLEMENTATION:
     from behave.version import VERSION as behave_version
-    if behave_version < minimal_version:
+    behave_version2 = behave_version.split(".")
+    minimal_version2 = minimal_version.split(".")
+    if behave_version2 < minimal_version2:
+        # -- USE: Tuple comparison as version comparison.
         raise ConstraintError("behave >= %s expected (was: %s)" % \
                               (minimal_version, behave_version))
diff --git a/behave/tag_matcher.py b/behave/tag_matcher.py
index 5f9dce0..e2b1e82 100644
--- a/behave/tag_matcher.py
+++ b/behave/tag_matcher.py
@@ -1,7 +1,7 @@
 # -*- coding: UTF-8 -*-
 """
-Contains classes and functionality to provide a skip-if logic based on tags
-in feature files.
+Contains classes and functionality to provide the active-tag mechanism.
+Active-tags provide a skip-if logic based on tags in feature files.
 """
 
 from __future__ import absolute_import
@@ -10,6 +10,11 @@ import operator
 import six
 
 
+def bool_to_string(value):
+    """Converts a Boolean value into its normalized string representation."""
+    return str(bool(value)).lower()
+
+
 class TagMatcher(object):
     """Abstract base class that defines the TagMatcher protocol."""
 
@@ -36,12 +41,13 @@ class TagMatcher(object):
 class ActiveTagMatcher(TagMatcher):
     """Provides an active tag matcher for many categories.
 
-    TAG SCHEMA:
+    TAG SCHEMA 1 (preferred):
       * use.with_{category}={value}
       * not.with_{category}={value}
+
+    TAG SCHEMA 2:
       * active.with_{category}={value}
       * not_active.with_{category}={value}
-      * only.with_{category}={value}        (NOTE: For backward compatibility)
 
     TAG LOGIC
     ----------
@@ -52,7 +58,7 @@ class ActiveTagMatcher(TagMatcher):
         active_group.enabled := enabled(group.tag1) or enabled(group.tag2) or ...
         active_tags.enabled  := enabled(group1) and enabled(group2) and ...
 
-    All active-tag groups must be turned "on".
+    All active-tag groups must be turned "on" (enabled).
     Otherwise, the model element should be excluded.
 
     CONCEPT: ValueProvider
@@ -81,12 +87,12 @@ class ActiveTagMatcher(TagMatcher):
         # -- FILE: features/alice.feature
         Feature:
 
-          @active.with_os=win32
+          @use.with_os=win32
           Scenario: Alice (Run only on Windows)
             Given I do something
             ...
 
-          @not_active.with_browser=chrome
+          @not.with_browser=chrome
           Scenario: Bob (Excluded with Web-Browser Chrome)
             Given I do something else
             ...
@@ -116,7 +122,7 @@ class ActiveTagMatcher(TagMatcher):
                 scenario.skip(exclude_reason)   #< LATE-EXCLUDE from run-set.
     """
     value_separator = "="
-    tag_prefixes = ["active", "not_active", "use", "not", "only"]
+    tag_prefixes = ["use", "not", "active", "not_active", "only"]
     tag_schema = r"^(?P<prefix>%s)\.with_(?P<category>\w+(\.\w+)*)%s(?P<value>.*)$"
     ignore_unknown_categories = True
     use_exclude_reason = False
@@ -163,21 +169,49 @@ class ActiveTagMatcher(TagMatcher):
 
     def is_tag_group_enabled(self, group_category, group_tag_pairs):
         """Provides boolean logic to determine if all active-tags
-        which use the same category result in a enabled value.
-
-        Use LOGICAL-OR expression for active-tags with same category::
-
-            category_tag_group.enabled := enabled(tag1) or enabled(tag2) or ...
+        which use the same category result in an enabled value.
 
         .. code-block:: gherkin
 
             @use.with_xxx=alice
             @use.with_xxx=bob
             @not.with_xxx=charly
+            @not.with_xxx=doro
             Scenario:
                 Given a step passes
                 ...
 
+        Use LOGICAL expression for active-tags with same category::
+
+            category_tag_group.enabled := positive-tag-expression and not negative-tag-expression
+              positive-tag-expression  := enabled(tag1) or enabled(tag2) or ...
+              negative-tag-expression  := enabled(tag3) or enabled(tag4) or ...
+               tag1, tag2 are positive-tags, like @use.with_category=value
+               tag3, tag4 are negative-tags, like @not.with_category=value
+
+             xxx   | Only use parts: (xxx == "alice") or (xxx == "bob")
+            -------+-------------------
+            alice  | true
+            bob    | true
+            other  | false
+
+             xxx   | Only not parts:
+                   | (not xxx == "charly") and (not xxx == "doro")
+                   | = not((xxx == "charly") or (xxx == "doro"))
+            -------+-------------------
+            charly | false
+            doro   | false
+            other  | true
+
+             xxx   | Use and not parts:
+                   | ((xxx == "alice") or (xxx == "bob")) and not((xxx == "charly") or (xxx == "doro"))
+            -------+-------------------
+            alice  | true
+            bob    | true
+            charly | false
+            doro   | false
+            other  | false
+
         :param group_category:      Category for this tag-group (as string).
         :param category_tag_group:  List of active-tag match-pairs.
         :return: True, if tag-group is enabled.
@@ -191,20 +225,28 @@ class ActiveTagMatcher(TagMatcher):
             # -- CASE: Unknown category, ignore it.
             return True
 
-        tags_enabled = []
+        positive_tags_matched = []
+        negative_tags_matched = []
         for category_tag, tag_match in group_tag_pairs:
             tag_prefix = tag_match.group("prefix")
             category = tag_match.group("category")
             tag_value = tag_match.group("value")
             assert category == group_category
 
-            is_category_tag_switched_on = operator.eq       # equal_to
             if self.is_tag_negated(tag_prefix):
-                is_category_tag_switched_on = operator.ne   # not_equal_to
-
-            tag_enabled = is_category_tag_switched_on(tag_value, current_value)
-            tags_enabled.append(tag_enabled)
-        return any(tags_enabled)    # -- PROVIDES: LOGICAL-OR expression
+                # -- CASE: @not.with_CATEGORY=VALUE
+                tag_matched = (tag_value == current_value)
+                negative_tags_matched.append(tag_matched)
+            else:
+                # -- CASE: @use.with_CATEGORY=VALUE
+                tag_matched = (tag_value == current_value)
+                positive_tags_matched.append(tag_matched)
+        tag_expression1 = any(positive_tags_matched)    #< LOGICAL-OR expression
+        tag_expression2 = any(negative_tags_matched)    #< LOGICAL-OR expression
+        if not positive_tags_matched:
+            tag_expression1 = True
+        tag_group_enabled = bool(tag_expression1 and not tag_expression2)
+        return tag_group_enabled
 
     def should_exclude_with(self, tags):
         group_categories = self.group_active_tags_by_category(tags)
diff --git a/features/tags.active_tags.feature b/features/tags.active_tags.feature
index 4ab55c2..6adcb60 100644
--- a/features/tags.active_tags.feature
+++ b/features/tags.active_tags.feature
@@ -240,9 +240,25 @@ Feature: Active Tags
         | tags                                      | enabled? | Comment |
         | @use.with_foo=xxx   @use.with_foo=other   |  yes     | Enabled: tag1 |
         | @use.with_foo=xxx   @not.with_foo=other   |  yes     | Enabled: tag1, tag2|
-        | @use.with_foo=xxx   @not.with_foo=xxx     |  yes     | Enabled: tag1 (BAD-SPEC) |
-        | @use.with_foo=other @not.with_foo=xxx     |  no      | Enabled: none |
-        | @not.with_foo=other @not.with_foo=xxx     |  yes     | Enabled: tag1 |
+        | @use.with_foo=other @not.with_foo=xxx     |  no      | Disabled: none |
+        | @not.with_foo=other @not.with_foo=xxx     |  no      | Disabled: tag1 |
+        | @use.with_foo=xxx   @not.with_foo=xxx     |  no      | Disabled: tag1 (BAD-SPEC, CONFLICTS) |
+
+
+  Scenario: Tag logic with three active tags of same category
+      Given I setup the current values for active tags with:
+        | category | value |
+        | foo      | xxx   |
+      Then the following active tag combinations are enabled:
+        | tags                                                        | enabled? | Comment |
+        | @use.with_foo=xxx  @use.with_foo=other @use.with_foo=other2|  yes     | Enabled: tag1  |
+        | @use.with_foo=xxx  @use.with_foo=other @not.with_foo=other2|  yes     | Enabled: tag1  |
+        | @use.with_foo=xxx  @not.with_foo=other @use.with_foo=other2|  yes     | Enabled: tag1  |
+        | @use.with_foo=xxx  @not.with_foo=other @not.with_foo=other2|  yes     | Enabled: tag1  |
+        | @not.with_foo=xxx  @use.with_foo=other @use.with_foo=other2|  no      | Disabled: tag1 |
+        | @not.with_foo=xxx  @use.with_foo=other @not.with_foo=other2|  no      | Disabled: tag1 |
+        | @not.with_foo=xxx  @not.with_foo=other @use.with_foo=other2|  no      | Disabled: tag1 |
+        | @not.with_foo=xxx  @not.with_foo=other @not.with_foo=other2|  no      | Disabled: tag1 |
 
 
     Scenario: Tag logic with unknown categories (case: ignored)
diff --git a/tests/functional/test_active_tags.py b/tests/functional/test_active_tags.py
new file mode 100644
index 0000000..fd6138f
--- /dev/null
+++ b/tests/functional/test_active_tags.py
@@ -0,0 +1,529 @@
+# -*- coding: utf-8 -*-
+"""
+Functionals tests for active tag-matcher (mod:`behave.tag_matcher`).
+"""
+
+from __future__ import absolute_import, print_function
+import pytest
+from behave.tag_matcher import ActiveTagMatcher
+
+# =============================================================================
+# TEST DATA:
+# =============================================================================
+# VALUE_PROVIDER = {
+#     "foo": "alice",
+#     "bar": "BOB",
+# }
+
+# =============================================================================
+# PYTEST FIXTURES:
+# =============================================================================
+# @pytest.fixture
+# def active_tag_matcher():
+#     tag_matcher = ActiveTagMatcher(VALUE_PROVIDER)
+#     return tag_matcher
+
+
+# =============================================================================
+# TEST SUITE:
+# =============================================================================
+class TestActivateTags(object):
+    VALUE_PROVIDER = {
+        "foo": "Frank",
+        "bar": "Bob",
+        # "OTHER": "VALUE",
+    }
+
+    def check_should_run_with_active_tags(self, case, expected, tags):
+        # -- tag_matcher.should_run_with(tags).result := expected
+        case += " (tags: {tags})"
+        tag_matcher = ActiveTagMatcher(self.VALUE_PROVIDER)
+        actual_result1 = tag_matcher.should_run_with(tags)
+        actual_result2 = tag_matcher.should_exclude_with(tags)
+        assert expected == actual_result1, case.format(tags=tags)
+        assert (not expected) == actual_result2
+
+    @pytest.mark.parametrize("case, expected, tags", [
+        ("use.with_foo=VALUE matches",     True, ["use.with_foo=Frank"]),
+        ("use.with_foo=VALUE mismatches", False, ["use.with_foo=OTHER"]),
+        ("not.with_foo=VALUE matches",    False, ["not.with_foo=Frank"]),
+        ("not.with_foo=VALUE mismatches",  True, ["not.with_foo=OTHER"]),
+        ("NO_TAGS", True, []),
+    ])
+    def test_one_tag_for_category1(self, case, expected, tags):
+        self.check_should_run_with_active_tags(case, expected, tags)
+
+    @pytest.mark.parametrize("case, expected, tags", [
+        ("use.with_bar=Bob matches",       True, ["use.with_bar=Bob"]),
+        ("use.with_bar=VALUE mismatches", False, ["use.with_bar=OTHER"]),
+        ("not.with_bar=VALUE matches",    False, ["not.with_bar=Bob"]),
+        ("not.with_bar=VALUE mismatches",  True, ["not.with_bar=OTHER"]),
+    ])
+    def test_one_tag_for_category2(self, case, expected, tags):
+        self.check_should_run_with_active_tags(case, expected, tags)
+
+    # @pytest.mark.parametrize("case, expected, tags", [
+    #     ("use.with_OTHER=VALUE matches",     True, ["use.with_OTHER=VALUE"]),
+    #     ("use.with_OTHER=VALUE mismatches", False, ["use.with_OTHER=OTHER"]),
+    #     ("not.with_OTHER=VALUE matches",    False, ["not.with_OTHER=VALUE"]),
+    #     ("not.with_OTHER=VALUE mismatches",  True, ["not.with_OTHER=OTHER"]),
+    # ])
+    # def test_one_tag_for_other_category(self, case, expected, tags):
+    #     self.check_should_run_with_active_tags(case, expected, tags)
+
+    @pytest.mark.parametrize("case, expected, tags", [
+        ("2x use.with_foo=VALUE: one matches", True,
+         ["use.with_foo=Frank", "use.with_foo=OTHER"]),
+        ("2x not.with_foo=VALUE: one matches", False,
+         ["not.with_foo=Frank", "not.with_foo=OTHER"]),
+        ("1x use./not.with_foo=VALUE: use-matches", True,
+         ["use.with_foo=Frank", "not.with_foo=OTHER"]),
+        ("1x use./not.with_foo=VALUE: not-matches", False,
+         ["not.with_foo=Frank", "use.with_foo=OTHER"]),
+    ])
+    def test_one_category_with_two_tags(self, case, expected, tags):
+        self.check_should_run_with_active_tags(case, expected, tags)
+
+    @pytest.mark.parametrize("case, expected, tags", [
+        ("3x use.with_foo=VALUE: one matches", True,
+         ["use.with_foo=Frank", "use.with_foo=OTHER_1", "use.with_foo=OTHER_2"]),
+        ("3x not.with_foo=VALUE: one matches", False,
+         ["not.with_foo=Frank", "not.with_foo=OTHER_1", "not.with_foo=OTHER_2"]),
+        ("2x use.with_foo=VALUE: use-matches", True,
+         ["use.with_foo=Frank", "use.with_foo=OTHER_1", "not.with_foo=OTHER_2"]),
+        ("2x not.with_foo=VALUE: not-matches", False,
+         ["not.with_foo=Frank", "not.with_foo=OTHER_1", "use.with_foo=OTHER_2"]),
+        ("1x use.with_foo=VALUE: use-matches", True,
+         ["use.with_foo=Frank", "not.with_foo=OTHER_1", "not.with_foo=OTHER_2"]),
+        ("1x not.with_foo=VALUE: not-matches", False,
+         ["not.with_foo=Frank", "use.with_foo=OTHER_1", "use.with_foo=OTHER_2"]),
+    ])
+    def test_one_category_with_three_tags(self, case, expected, tags):
+        self.check_should_run_with_active_tags(case, expected, tags)
+
+    @pytest.mark.parametrize("case, expected, tags", [
+        # -- use.with_CATEGORY=VALUE
+        ("use.with_... 2x matches",      True, ["use.with_foo=Frank", "use.with_bar=Bob"]),
+        ("use.with_... 1x matches",     False, ["use.with_foo=Frank", "use.with_bar=OTHER"]),
+        ("use.with_... 1x matches",     False, ["use.with_foo=OTHER", "use.with_bar=OTHER"]),
+        ("use.with_... 1x matches",     False, ["use.with_foo=OTHER", "use.with_bar=Bob"]),
+        ("use.with_... 0x matches",     False, ["use.with_foo=OTHER", "use.with_bar=OTHER"]),
+        # -- not.with_CATEGORY=VALUE
+        ("not.with_... 2x matches", False, ["not.with_foo=Frank", "not.with_bar=Bob"]),
+        ("not.with_... 1x matches", False, ["not.with_foo=Frank", "not.with_bar=OTHER"]),
+        ("not.with_... 1x matches", False, ["not.with_foo=OTHER", "not.with_bar=Bob"]),
+        ("not.with_... 0x matches",  True, ["not.with_foo=OTHER", "not.with_bar=OTHER"]),
+        # -- use.with_CATEGORY_1=VALUE_1, not.with_CATEGORY_2=VALUE_2
+        ("use./not.with_... use-matches",  True, ["use.with_foo=Frank", "not.with_bar=OTHER"]),
+        ("use./not.with_... not-matches", False, ["use.with_foo=OTHER", "not.with_bar=Bob"]),
+        ("use./not.with_... 2x matches",  False, ["use.with_foo=Frank", "not.with_bar=Bob"]),
+        ("use./not.with_... 0x matches",  False, ["use.with_foo=OTHER", "not.with_bar=OTHER"]),
+    ])
+    def test_two_categories_with_two_tags(self, case, expected, tags):
+        self.check_should_run_with_active_tags(case, expected, tags)
+
+    @pytest.mark.parametrize("case, expected, tags", [
+        # -- use.with_CATEGORY=VALUE
+        ("use.with_... 2x matches",      True, ["use.with_foo=Frank", "use.with_foo=OTHER", "use.with_bar=Bob"]),
+        ("use.with_... 1x matches",     False, ["use.with_foo=Frank", "use.with_foo=OTHER", "use.with_bar=OTHER"]),
+        ("use.with_... 1x matches",     False, ["use.with_foo=OTHER", "use.with_foo=Frank", "use.with_bar=OTHER"]),
+        ("use.with_... 1x matches",     False, ["use.with_foo=OTHER", "use.with_foo=OTHER2", "use.with_bar=Bob"]),
+        ("use.with_... 0x matches",     False, ["use.with_foo=OTHER", "use.with_bar=OTHER2", "use.with_bar=OTHER"]),
+        # -- not.with_CATEGORY=VALUE
+        ("not.with_... 2x matches", False, ["not.with_foo=Frank", "not.with_foo=OTHER", "not.with_bar=Bob"]),
+        ("not.with_... 1x matches", False, ["not.with_foo=Frank", "not.with_foo=OTHER", "not.with_bar=OTHER"]),
+        ("not.with_... 1x matches", False, ["not.with_foo=OTHER", "not.with_foo=OTHER2", "not.with_bar=Bob"]),
+        ("not.with_... 0x matches",  True, ["not.with_foo=OTHER", "not.with_foo=OTHER2", "not.with_bar=OTHER"]),
+        # -- use.with_CATEGORY_1=VALUE_1, not.with_CATEGORY_2=VALUE_2
+        ("use./not.with_... use-matches",  True, ["use.with_foo=Frank", "use.with_foo=OTHER", "not.with_bar=OTHER"]),
+        ("use./not.with_... not-matches", False, ["use.with_foo=OTHER", "use.with_foo=OTHER2", "not.with_bar=Bob"]),
+        ("use./not.with_... 2x matches",  False, ["use.with_foo=Frank", "use.with_foo=OTHER", "not.with_bar=Bob"]),
+        ("use./not.with_... 0x matches",  False, ["use.with_foo=OTHER", "use.with_foo=OTHER2", "not.with_bar=OTHER"]),
+        # -- not.with_CATEGORY_1=VALUE_1, use.with_CATEGORY_2=VALUE_2
+        ("use./not.with_... not-matches", False, ["not.with_foo=Frank", "not.with_foo=OTHER", "use.with_bar=OTHER"]),
+        ("use./not.with_... use-matches", True, ["not.with_foo=OTHER", "not.with_foo=OTHER2", "use.with_bar=Bob"]),
+        ("use./not.with_... 2x matches", False, ["not.with_foo=Frank", "not.with_foo=OTHER", "use.with_bar=Bob"]),
+        ("use./not.with_... 0x matches", False, ["not.with_foo=OTHER", "not.with_foo=OTHER2", "use.with_bar=OTHER"]),
+    ])
+    def test_two_categories_with_three_tags(self, case, expected, tags):
+        self.check_should_run_with_active_tags(case, expected, tags)
+
+'''
+class Traits4ActiveTagMatcher(object):
+    TagMatcher = ActiveTagMatcher
+    value_provider = {
+        "foo": "alice",
+        "bar": "BOB",
+    }
+
+    category1_enabled_tag = TagMatcher.make_category_tag("foo", "alice")
+    category1_disabled_tag = TagMatcher.make_category_tag("foo", "bob")
+    category1_disabled_tag2 = TagMatcher.make_category_tag("foo", "charly")
+    category1_similar_tag = TagMatcher.make_category_tag("foo", "alice2")
+    category2_enabled_tag = TagMatcher.make_category_tag("bar", "BOB")
+    category2_disabled_tag = TagMatcher.make_category_tag("bar", "CHARLY")
+    category2_similar_tag = TagMatcher.make_category_tag("bar", "BOB2")
+    unknown_category_tag = TagMatcher.make_category_tag("UNKNOWN", "one")
+
+    # -- NEGATED TAGS:
+    category1_not_enabled_tag = \
+        TagMatcher.make_category_tag("foo", "alice", "not_active")
+    category1_not_enabled_tag2 = \
+        TagMatcher.make_category_tag("foo", "alice", "not")
+    category1_not_disabled_tag = \
+        TagMatcher.make_category_tag("foo", "bob", "not_active")
+    category1_negated_similar_tag1 = \
+        TagMatcher.make_category_tag("foo", "alice2", "not_active")
+
+
+    active_tags1 = [
+        category1_enabled_tag, category1_disabled_tag, category1_similar_tag,
+        category1_not_enabled_tag, category1_not_enabled_tag2,
+    ]
+    active_tags2 = [
+        category2_enabled_tag, category2_disabled_tag, category2_similar_tag,
+    ]
+    active_tags = active_tags1 + active_tags2
+
+
+# -- REQUIRES: pytest
+class TestActiveTagMatcher2(object):
+    TagMatcher = ActiveTagMatcher
+    traits = Traits4ActiveTagMatcher
+
+    @classmethod
+    def make_tag_matcher(cls):
+        value_provider = {
+            "foo": "alice",
+            "bar": "BOB",
+        }
+        tag_matcher = cls.TagMatcher(value_provider)
+        return tag_matcher
+
+    @pytest.mark.parametrize("case, expected_len, tags", [
+        ("case: Two enabled tags", 2,
+         [traits.category1_enabled_tag, traits.category2_enabled_tag]),
+        ("case: Active enabled and normal tag", 1,
+         [traits.category1_enabled_tag,  "foo"]),
+        ("case: Active disabled and normal tag", 1,
+         [traits.category1_disabled_tag, "foo"]),
+        ("case: Normal and active negated tag", 1,
+         ["foo", traits.category1_not_enabled_tag]),
+        ("case: Two normal tags", 0,
+         ["foo", "bar"]),
+    ])
+    def test_select_active_tags__with_two_tags(self, case, expected_len, tags):
+        tag_matcher = self.make_tag_matcher()
+        selected = tag_matcher.select_active_tags(tags)
+        selected = list(selected)
+        assert len(selected) == expected_len, case
+
+    @pytest.mark.parametrize("case, expected, tags", [
+        # -- GROUP: With positive logic (non-negated tags)
+        ("case P00: 2 disabled tags", True,
+         [ traits.category1_disabled_tag, traits.category2_disabled_tag]),
+        ("case P01: disabled and enabled tag", True,
+         [ traits.category1_disabled_tag, traits.category2_enabled_tag]),
+        ("case P10: enabled and disabled tag", True,
+         [ traits.category1_enabled_tag, traits.category2_disabled_tag]),
+        ("case P11: 2 enabled tags", False,  # -- SHOULD-RUN
+         [ traits.category1_enabled_tag, traits.category2_enabled_tag]),
+        # -- GROUP: With negated tag
+        ("case N00: not-enabled and disabled tag", True,
+         [ traits.category1_not_enabled_tag, traits.category2_disabled_tag]),
+        ("case N01: not-enabled and enabled tag", True,
+         [ traits.category1_not_enabled_tag, traits.category2_enabled_tag]),
+        ("case N10: not-disabled and disabled tag", True,
+         [ traits.category1_not_disabled_tag, traits.category2_disabled_tag]),
+        ("case N11: not-disabled and enabled tag", False, # -- SHOULD-RUN
+         [ traits.category1_not_disabled_tag, traits.category2_enabled_tag]),
+        # -- GROUP: With unknown category
+        ("case U0x: disabled and unknown tag", True,
+         [ traits.category1_disabled_tag, traits.unknown_category_tag]),
+        ("case U1x: enabled and unknown tag", False,  # -- SHOULD-RUN
+         [ traits.category1_enabled_tag, traits.unknown_category_tag]),
+    ])
+    def test_should_exclude_with__combinations_of_2_categories(self, case, expected, tags):
+        tag_matcher = self.make_tag_matcher()
+        actual_result = tag_matcher.should_exclude_with(tags)
+        assert expected == actual_result, case
+
+    @pytest.mark.parametrize("case, expected, tags", [
+        # -- GROUP: With positive logic (non-negated tags)
+        ("case P00: 2 disabled tags", True,
+         [ traits.category1_disabled_tag, traits.category1_disabled_tag2]),
+        ("case P01: disabled and enabled tag", False,
+         [ traits.category1_disabled_tag, traits.category1_enabled_tag]),
+        ("case P10: enabled and disabled tag", False,
+         [ traits.category1_enabled_tag, traits.category1_disabled_tag]),
+        ("case P11: 2 enabled tags (same)", False,  # -- SHOULD-RUN
+         [ traits.category1_enabled_tag, traits.category1_enabled_tag]),
+        # -- GROUP: With negated tag
+        ("case N00: not-enabled and disabled tag", True,
+         [ traits.category1_not_enabled_tag, traits.category1_disabled_tag]),
+        ("case N01: not-enabled and enabled tag", True,
+         [ traits.category1_not_enabled_tag, traits.category1_enabled_tag]),
+        ("case N10: not-disabled and disabled tag", True,
+         [ traits.category1_not_disabled_tag, traits.category1_disabled_tag]),
+        ("case N11: not-disabled and enabled tag", False, # -- SHOULD-RUN
+         [ traits.category1_not_disabled_tag, traits.category1_enabled_tag]),
+    ])
+    def test_should_exclude_with__combinations_with_same_category(self,
+                                                        case, expected, tags):
+        tag_matcher = self.make_tag_matcher()
+        print("tags: {}".format(tags) )
+        print("tag_matcher.value: {}".format(tag_matcher.value_provider) )
+        actual_result = tag_matcher.should_exclude_with(tags)
+        assert expected == actual_result, case
+
+
+class TestActiveTags(TestCase):
+    TagMatcher = ActiveTagMatcher
+    traits = Traits4ActiveTagMatcher
+
+    @classmethod
+    def make_tag_matcher(cls):
+        tag_matcher = cls.TagMatcher(cls.traits.value_provider)
+        return tag_matcher
+
+    def setUp(self):
+        self.tag_matcher = self.make_tag_matcher()
+
+    def test_select_active_tags__basics(self):
+        active_tag = "active.with_CATEGORY=VALUE"
+        tags = ["foo", active_tag, "bar"]
+        selected = list(self.tag_matcher.select_active_tags(tags))
+        self.assertEqual(len(selected), 1)
+        selected_tag, selected_match = selected[0]
+        self.assertEqual(selected_tag, active_tag)
+
+    def test_select_active_tags__matches_tag_parts(self):
+        tags = ["active.with_CATEGORY=VALUE"]
+        selected = list(self.tag_matcher.select_active_tags(tags))
+        self.assertEqual(len(selected), 1)
+        selected_tag, selected_match = selected[0]
+        self.assertEqual(selected_match.group("prefix"), "active")
+        self.assertEqual(selected_match.group("category"), "CATEGORY")
+        self.assertEqual(selected_match.group("value"), "VALUE")
+
+    def test_select_active_tags__finds_tag_with_any_valid_tag_prefix(self):
+        TagMatcher = self.TagMatcher
+        for tag_prefix in TagMatcher.tag_prefixes:
+            tag = TagMatcher.make_category_tag("foo", "alice", tag_prefix)
+            tags = [ tag ]
+            selected = self.tag_matcher.select_active_tags(tags)
+            selected = list(selected)
+            self.assertEqual(len(selected), 1)
+            selected_tag0 = selected[0][0]
+            self.assertEqual(selected_tag0, tag)
+            self.assertTrue(selected_tag0.startswith(tag_prefix))
+
+    def test_select_active_tags__ignores_invalid_active_tags(self):
+        invalid_active_tags = [
+            ("foo.alice",               "case: Normal tag"),
+            ("with_foo=Frank",          "case: Subset of an active tag"),
+            ("ACTIVE.with_foo.alice",   "case: Wrong tag_prefix (uppercase)"),
+            ("only.with_foo.alice",     "case: Wrong value_separator"),
+        ]
+        for invalid_tag, case in invalid_active_tags:
+            tags = [ invalid_tag ]
+            selected = self.tag_matcher.select_active_tags(tags)
+            selected = list(selected)
+            self.assertEqual(len(selected), 0, case)
+
+    def test_select_active_tags__with_two_tags(self):
+        # XXX-JE-DUPLICATED:
+        traits = self.traits
+        test_patterns = [
+            ("case: Two enabled tags",
+             [traits.category1_enabled_tag, traits.category2_enabled_tag]),
+            ("case: Active enabled and normal tag",
+             [traits.category1_enabled_tag,  "foo"]),
+            ("case: Active disabled and normal tag",
+             [traits.category1_disabled_tag, "foo"]),
+            ("case: Active negated and normal tag",
+             [traits.category1_not_enabled_tag, "foo"]),
+        ]
+        for case, tags in test_patterns:
+            selected = self.tag_matcher.select_active_tags(tags)
+            selected = list(selected)
+            self.assertTrue(len(selected) >= 1, case)
+
+
+    def test_should_exclude_with__returns_false_with_enabled_tag(self):
+        traits = self.traits
+        tags1 = [ traits.category1_enabled_tag ]
+        tags2 = [ traits.category2_enabled_tag ]
+        self.assertEqual(False, self.tag_matcher.should_exclude_with(tags1))
+        self.assertEqual(False, self.tag_matcher.should_exclude_with(tags2))
+
+    def test_should_exclude_with__returns_false_with_disabled_tag_and_more(self):
+        # -- NOTE: Need 1+ enabled active-tags of same category => ENABLED
+        # pylint: disable=line-too-long
+        traits = self.traits
+        test_patterns = [
+            ([ traits.category1_enabled_tag, traits.category1_disabled_tag ], "case: first"),
+            ([ traits.category1_disabled_tag, traits.category1_enabled_tag ], "case: last"),
+            ([ "foo", traits.category1_enabled_tag, traits.category1_disabled_tag, "bar" ], "case: middle"),
+        ]
+        enabled = True  # EXPECTED
+        for tags, case in test_patterns:
+            self.assertEqual(not enabled, self.tag_matcher.should_exclude_with(tags),
+                             "%s: tags=%s" % (case, tags))
+
+    def test_should_exclude_with__returns_true_with_other_tag(self):
+        traits = self.traits
+        tags = [ traits.category1_disabled_tag ]
+        self.assertEqual(True, self.tag_matcher.should_exclude_with(tags))
+
+    def test_should_exclude_with__returns_true_with_other_tag_and_more(self):
+        traits = self.traits
+        test_patterns = [
+            ([ traits.category1_disabled_tag, "foo" ], "case: first"),
+            ([ "foo", traits.category1_disabled_tag ], "case: last"),
+            ([ "foo", traits.category1_disabled_tag, "bar" ], "case: middle"),
+        ]
+        for tags, case in test_patterns:
+            self.assertEqual(True, self.tag_matcher.should_exclude_with(tags),
+                             "%s: tags=%s" % (case, tags))
+
+    def test_should_exclude_with__returns_true_with_similar_tag(self):
+        traits = self.traits
+        tags = [ traits.category1_similar_tag ]
+        self.assertEqual(True, self.tag_matcher.should_exclude_with(tags))
+
+    def test_should_exclude_with__returns_true_with_similar_and_more(self):
+        traits = self.traits
+        test_patterns = [
+            ([ traits.category1_similar_tag, "foo" ], "case: first"),
+            ([ "foo", traits.category1_similar_tag ], "case: last"),
+            ([ "foo", traits.category1_similar_tag, "bar" ], "case: middle"),
+        ]
+        for tags, case in test_patterns:
+            self.assertEqual(True, self.tag_matcher.should_exclude_with(tags),
+                             "%s: tags=%s" % (case, tags))
+
+    def test_should_exclude_with__returns_false_without_category_tag(self):
+        test_patterns = [
+            ([ ],           "case: No tags"),
+            ([ "foo" ],     "case: One tag"),
+            ([ "foo", "bar" ], "case: Two tags"),
+        ]
+        for tags, case in test_patterns:
+            self.assertEqual(False, self.tag_matcher.should_exclude_with(tags),
+                             "%s: tags=%s" % (case, tags))
+
+    def test_should_exclude_with__returns_false_with_unknown_category_tag(self):
+        """Tags from unknown categories, not supported by value_provider,
+        should not be excluded.
+        """
+        traits = self.traits
+        tags = [ traits.unknown_category_tag ]
+        self.assertEqual("use.with_UNKNOWN=one", traits.unknown_category_tag)
+        self.assertEqual(None, self.tag_matcher.value_provider.get("UNKNOWN"))
+        self.assertEqual(False, self.tag_matcher.should_exclude_with(tags))
+
+    def test_should_exclude_with__combinations_of_2_categories(self):
+        # XXX-JE-DUPLICATED:
+        traits = self.traits
+        test_patterns = [
+            ("case P00: 2 disabled category tags", True,
+             [ traits.category1_disabled_tag, traits.category2_disabled_tag]),
+            ("case P01: disabled and enabled category tags", True,
+             [ traits.category1_disabled_tag, traits.category2_enabled_tag]),
+            ("case P10: enabled and disabled category tags", True,
+             [ traits.category1_enabled_tag, traits.category2_disabled_tag]),
+            ("case P11: 2 enabled category tags", False,  # -- SHOULD-RUN
+             [ traits.category1_enabled_tag, traits.category2_enabled_tag]),
+            # -- SPECIAL CASE: With negated category
+            ("case N00: not-enabled and disabled category tags", True,
+             [ traits.category1_not_enabled_tag, traits.category2_disabled_tag]),
+            ("case N01: not-enabled and enabled category tags", True,
+             [ traits.category1_not_enabled_tag, traits.category2_enabled_tag]),
+            ("case N10: not-disabled and disabled category tags", True,
+             [ traits.category1_not_disabled_tag, traits.category2_disabled_tag]),
+            ("case N11: not-enabled and enabled category tags", False,  # -- SHOULD-RUN
+             [ traits.category1_not_disabled_tag, traits.category2_enabled_tag]),
+            # -- SPECIAL CASE: With unknown category
+            ("case 0x: disabled and unknown category tags", True,
+             [ traits.category1_disabled_tag, traits.unknown_category_tag]),
+            ("case 1x: enabled and unknown category tags", False,  # SHOULD-RUN
+             [ traits.category1_enabled_tag, traits.unknown_category_tag]),
+        ]
+        for case, expected, tags in test_patterns:
+            actual_result = self.tag_matcher.should_exclude_with(tags)
+            self.assertEqual(expected, actual_result,
+                             "%s: tags=%s" % (case, tags))
+
+    def test_should_run_with__negates_result_of_should_exclude_with(self):
+        traits = self.traits
+        test_patterns = [
+            ([ ],                   "case: No tags"),
+            ([ "foo" ],             "case: One non-category tag"),
+            ([ "foo", "bar" ],      "case: Two non-category tags"),
+            ([ traits.category1_enabled_tag ],   "case: enabled tag"),
+            ([ traits.category1_enabled_tag, traits.category1_disabled_tag ],  "case: enabled and other tag"),
+            ([ traits.category1_enabled_tag, "foo" ],    "case: enabled and foo tag"),
+            ([ traits.category1_disabled_tag ],            "case: other tag"),
+            ([ traits.category1_disabled_tag, "foo" ],     "case: other and foo tag"),
+            ([ traits.category1_similar_tag ],          "case: similar tag"),
+            ([ "foo", traits.category1_similar_tag ],   "case: foo and similar tag"),
+        ]
+        for tags, case in test_patterns:
+            result1 = self.tag_matcher.should_run_with(tags)
+            result2 = self.tag_matcher.should_exclude_with(tags)
+            self.assertEqual(result1, not result2, "%s: tags=%s" % (case, tags))
+            self.assertEqual(not result1, result2, "%s: tags=%s" % (case, tags))
+
+
+class TestCompositeTagMatcher(TestCase):
+
+    @staticmethod
+    def count_tag_matcher_with_result(tag_matchers, tags, result_value):
+        count = 0
+        for tag_matcher in tag_matchers:
+            current_result = tag_matcher.should_exclude_with(tags)
+            if current_result == result_value:
+                count += 1
+        return count
+
+    def setUp(self):
+        predicate_false = lambda tags: False
+        predicate_contains_foo = lambda tags: any(x == "foo" for x in tags)
+        self.tag_matcher_false = PredicateTagMatcher(predicate_false)
+        self.tag_matcher_foo = PredicateTagMatcher(predicate_contains_foo)
+        tag_matchers = [
+            self.tag_matcher_foo,
+            self.tag_matcher_false
+        ]
+        self.ctag_matcher = CompositeTagMatcher(tag_matchers)
+
+    def test_should_exclude_with__returns_true_when_any_tag_matcher_returns_true(self):
+        test_patterns = [
+            ("case: with foo",  ["foo", "bar"]),
+            ("case: with foo2", ["foozy", "foo", "bar"]),
+        ]
+        for case, tags in test_patterns:
+            actual_result = self.ctag_matcher.should_exclude_with(tags)
+            self.assertEqual(True, actual_result,
+                             "%s: tags=%s" % (case, tags))
+
+            actual_true_count = self.count_tag_matcher_with_result(
+                                self.ctag_matcher.tag_matchers, tags, True)
+            self.assertEqual(1, actual_true_count)
+
+    def test_should_exclude_with__returns_false_when_no_tag_matcher_return_true(self):
+        test_patterns = [
+            ("case: without foo",   ["fool", "bar"]),
+            ("case: without foo2",  ["foozy", "bar"]),
+        ]
+        for case, tags in test_patterns:
+            actual_result = self.ctag_matcher.should_exclude_with(tags)
+            self.assertEqual(False, actual_result,
+                             "%s: tags=%s" % (case, tags))
+
+            actual_true_count = self.count_tag_matcher_with_result(
+                                    self.ctag_matcher.tag_matchers, tags, True)
+            self.assertEqual(0, actual_true_count)
+'''
+
diff --git a/tests/unit/test_tag_matcher.py b/tests/unit/test_tag_matcher.py
index a04c1d4..43f5af0 100644
--- a/tests/unit/test_tag_matcher.py
+++ b/tests/unit/test_tag_matcher.py
@@ -128,9 +128,9 @@ class TestActiveTagMatcher2(object):
         # -- GROUP: With negated tag
         ("case N00: not-enabled and disabled tag", True,
          [ traits.category1_not_enabled_tag, traits.category1_disabled_tag]),
-        ("case N01: not-enabled and enabled tag", False,
+        ("case N01: not-enabled and enabled tag", True,
          [ traits.category1_not_enabled_tag, traits.category1_enabled_tag]),
-        ("case N10: not-disabled and disabled tag", False,
+        ("case N10: not-disabled and disabled tag", True,
          [ traits.category1_not_disabled_tag, traits.category1_disabled_tag]),
         ("case N11: not-disabled and enabled tag", False, # -- SHOULD-RUN
          [ traits.category1_not_disabled_tag, traits.category1_enabled_tag]),
@@ -138,6 +138,8 @@ class TestActiveTagMatcher2(object):
     def test_should_exclude_with__combinations_with_same_category(self,
                                                         case, expected, tags):
         tag_matcher = self.make_tag_matcher()
+        print("tags: {}".format(tags) )
+        print("tag_matcher.value: {}".format(tag_matcher.value_provider) )
         actual_result = tag_matcher.should_exclude_with(tags)
         assert expected == actual_result, case
 
@@ -224,6 +226,7 @@ class TestActiveTagMatcher1(TestCase):
 
     def test_should_exclude_with__returns_false_with_disabled_tag_and_more(self):
         # -- NOTE: Need 1+ enabled active-tags of same category => ENABLED
+        # pylint: disable=line-too-long
         traits = self.traits
         test_patterns = [
             ([ traits.category1_enabled_tag, traits.category1_disabled_tag ], "case: first"),
@@ -283,7 +286,7 @@ class TestActiveTagMatcher1(TestCase):
         """
         traits = self.traits
         tags = [ traits.unknown_category_tag ]
-        self.assertEqual("active.with_UNKNOWN=one", traits.unknown_category_tag)
+        self.assertEqual("use.with_UNKNOWN=one", traits.unknown_category_tag)
         self.assertEqual(None, self.tag_matcher.value_provider.get("UNKNOWN"))
         self.assertEqual(False, self.tag_matcher.should_exclude_with(tags))
 
@@ -376,42 +379,6 @@ class TestPredicateTagMatcher(TestCase):
         self.assertEqual(False, predicate_always_false(tags))
 
 
-class TestPredicateTagMatcher(TestCase):
-
-    def test_exclude_with__mechanics(self):
-        predicate_function_blueprint = lambda tags: False
-        predicate_function = Mock(predicate_function_blueprint)
-        predicate_function.return_value = True
-        tag_matcher = PredicateTagMatcher(predicate_function)
-        tags = [ "foo", "bar" ]
-        self.assertEqual(True, tag_matcher.should_exclude_with(tags))
-        predicate_function.assert_called_once_with(tags)
-        self.assertEqual(True, predicate_function(tags))
-
-    def test_should_exclude_with__returns_true_when_predicate_is_true(self):
-        predicate_always_true = lambda tags: True
-        tag_matcher1 = PredicateTagMatcher(predicate_always_true)
-        tags = [ "foo", "bar" ]
-        self.assertEqual(True, tag_matcher1.should_exclude_with(tags))
-        self.assertEqual(True, predicate_always_true(tags))
-
-    def test_should_exclude_with__returns_true_when_predicate_is_true2(self):
-        # -- CASE: Use predicate function instead of lambda.
-        def predicate_contains_foo(tags):
-            return any(x == "foo" for x in tags)
-        tag_matcher2 = PredicateTagMatcher(predicate_contains_foo)
-        tags = [ "foo", "bar" ]
-        self.assertEqual(True, tag_matcher2.should_exclude_with(tags))
-        self.assertEqual(True, predicate_contains_foo(tags))
-
-    def test_should_exclude_with__returns_false_when_predicate_is_false(self):
-        predicate_always_false = lambda tags: False
-        tag_matcher1 = PredicateTagMatcher(predicate_always_false)
-        tags = [ "foo", "bar" ]
-        self.assertEqual(False, tag_matcher1.should_exclude_with(tags))
-        self.assertEqual(False, predicate_always_false(tags))
-
-
 class TestCompositeTagMatcher(TestCase):
 
     @staticmethod
