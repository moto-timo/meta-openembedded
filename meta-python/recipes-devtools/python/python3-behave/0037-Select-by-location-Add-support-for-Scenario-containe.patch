From f0344ab331b3fd642853f58145c6b9ba566a2e1f Mon Sep 17 00:00:00 2001
From: jenisys <jenisys@users.noreply.github.com>
Date: Sat, 6 Jul 2019 09:50:46 +0200
Subject: [PATCH] Select-by-location: Add support for "Scenario container"
 (Feature, Rule, ScenarioOutline) (related to: #391)

---
 CHANGES.rst                                   |   2 +-
 behave/model.py                               |  49 +++--
 behave/runner_util.py                         | 186 +++++++++++++++++-
 ....select_scenarios_by_file_location.feature |  27 ++-
 pytest.ini                                    |   2 +-
 tests/unit/test_runner_util.py                | 175 ++++++++++++++++
 6 files changed, 416 insertions(+), 25 deletions(-)
 create mode 100644 tests/unit/test_runner_util.py

diff --git a/CHANGES.rst b/CHANGES.rst
index 3d805b3..01bd1bd 100644
--- a/CHANGES.rst
+++ b/CHANGES.rst
@@ -28,7 +28,7 @@ ENHANCEMENTS:
 * Use `cucumber-tag-expressions`_ with tag-matching extension (superceeds: old-style tag-expressions)
 * issue #678: Scenario Outline: Support tags with commas and semicolons (provided by: lawnmowerlatte, pull #679)
 * issue #675: Feature files cannot be found within symlink directories (provided by: smadness, pull #680)
-
+* Select-by-location: Add support for "Scenario container" (Feature, Rule, ScenarioOutline) (related to: #391)
 
 PARTIALLY FIXED:
 
diff --git a/behave/model.py b/behave/model.py
index 3084850..7fc534a 100644
--- a/behave/model.py
+++ b/behave/model.py
@@ -55,11 +55,11 @@ class ScenarioContainer(TagAndStatusStatement, Replayable):
     .. attribute:: keyword
 
        This is the keyword as seen in the *feature file*. In English this will
-       be "Feature".
+       be "Feature" or "Rule".
 
     .. attribute:: name
 
-       The name of the feature (the text after "Feature".)
+       The name (or title) of the model entity (the text after the keyword.)
 
     .. attribute:: description
 
@@ -93,12 +93,16 @@ class ScenarioContainer(TagAndStatusStatement, Replayable):
 
        Status.untested
          The feature was has not been completely tested yet.
+
        Status.skipped
-         One or more steps of this feature was passed over during testing.
+         The execution of this model entity (feature or rule)
+         should be / was skipped (excluded from the test run).
+
        Status.passed
-         The feature was tested successfully.
+         The model entity (feature or rule) was tested successfully.
+
        Status.failed
-         One or more steps of this feature failed.
+         One or more run items of this model entity failed.
 
        .. versionchanged:: 1.2.6
             Use Status enum class (was: string).
@@ -147,6 +151,11 @@ class ScenarioContainer(TagAndStatusStatement, Replayable):
         for run_item in self.run_items:
             run_item.reset()
 
+    def _setup_context_for_run(self, context):
+        """Setup/Init runner context for run."""
+        # -- OVERRIDDEN: By derived classes.
+        pass
+
     def __iter__(self):
         return iter(self.run_items)
 
@@ -204,7 +213,7 @@ class ScenarioContainer(TagAndStatusStatement, Replayable):
         # feature_duration = self.run_endtime - self.run_starttime
         return feature_duration
 
-    def walk_scenarios(self, with_outlines=False):
+    def walk_scenarios(self, with_outlines=False, with_rules=False):
         """Provides a flat list of all scenarios of this ScenarioContainer.
         A ScenarioOutline element adds its scenarios to this list.
         But the ScenarioOutline element itself is only added when specified.
@@ -215,20 +224,20 @@ class ScenarioContainer(TagAndStatusStatement, Replayable):
         :param with_outlines: If ScenarioOutline items should be added, too.
         :return: List of all scenarios of this feature.
         """
-        # TODO: Better use self.run_items
         all_scenarios = []
-        # for scenario in self.scenarios:
         for run_item in self.run_items:
             if isinstance(run_item, Rule):
                 rule = run_item
+                if with_rules:
+                    all_scenarios.append(rule)
                 all_scenarios.extend(rule.walk_scenarios(with_outlines=with_outlines))
-            if isinstance(run_item, ScenarioOutline):
+            elif isinstance(run_item, ScenarioOutline):
                 scenario_outline = run_item
                 if with_outlines:
                     all_scenarios.append(scenario_outline)
                 all_scenarios.extend(scenario_outline.scenarios)
             else:
-                assert isinstance(run_item, Scenario)
+                assert isinstance(run_item, Scenario), "OOPS: %r" % run_item
                 all_scenarios.append(run_item)
         return all_scenarios
 
@@ -274,9 +283,9 @@ class ScenarioContainer(TagAndStatusStatement, Replayable):
         assert self.status == Status.skipped or self.hook_failed
 
     def skip(self, reason=None, require_not_executed=False):
-        """Skip executing this feature or the remaining parts of it.
-        Note that this feature may be already partly executed
-        when this function is called.
+        """Skip executing this model entity or the remaining parts of it.
+        Note that this model entity (feature or rule) may be already partly
+        executed when this function is called.
 
         :param reason:  Optional reason why feature should be skipped (as string).
         :param require_not_executed: Optional, requires that feature is not
@@ -314,8 +323,8 @@ class ScenarioContainer(TagAndStatusStatement, Replayable):
         hook_after_entity = "after_{0}".format(entity_name)
 
         runner.context._push(layer_name=entity_name)      # pylint: disable=protected-access
-        runner.context.feature = self
         runner.context.tags = set(self.tags)
+        self._setup_context_for_run(runner.context)
 
         skip_entity_untested = runner.aborted
         should_run_entity = self.should_run(runner.config)
@@ -497,6 +506,9 @@ class Feature(ScenarioContainer):
             (self.name, len(self.run_items),
              len(self.rules), len(self.scenarios))
 
+    def _setup_context_for_run(self, context):
+        context.feature = self
+
     def add_rule(self, rule):
         """Add a rule to this feature."""
         feature = self
@@ -619,6 +631,9 @@ class Rule(ScenarioContainer):
         self.parent = parent
         self.feature = parent
 
+    def _setup_context_for_run(self, context):
+        context.rule = self
+
     def __repr__(self):
         return '<Rule "%s": %d scenario(s)>' % \
             (self.name, len(self.scenarios))
@@ -664,6 +679,10 @@ class Background(BasicStatement, Replayable):
 
     .. _`background`: gherkin.html#backgrounds
     """
+    # TODO: Background inheritance
+    # Rule.background should inherit its Feature.background steps (if available)
+    # Rule.background = Feature.background iff not Rule.background exists (ALREADY-SOLVED)
+    # Rule may override background inheritance mechanism
     type = "background"
 
     def __init__(self, filename, line, keyword, name, steps=None, description=None):
@@ -796,7 +815,7 @@ class Scenario(TagAndStatusStatement, Replayable):
 
     @property
     def background_steps(self):
-        """Provide background steps if feature has a background.
+        """Provide background steps if feature/rule has a background.
         Lazy init that copies the background steps.
 
         Note that a copy of the background steps is needed to ensure
diff --git a/behave/runner_util.py b/behave/runner_util.py
index 2210f78..7e0807f 100644
--- a/behave/runner_util.py
+++ b/behave/runner_util.py
@@ -58,6 +58,100 @@ class FileLocationParser(object):
 # -----------------------------------------------------------------------------
 # CLASSES:
 # -----------------------------------------------------------------------------
+from collections import OrderedDict
+from .model import Feature, Rule, ScenarioOutline, Scenario
+
+
+class FeatureLineDatabase(object):
+    """Helper class that supports select-by-location mechanism (FileLocation)
+    within a feature file by storing the feature line numbers for each entity.
+
+    RESPONSIBILITY(s):
+
+    * Can use the line number to select the best matching entity(s) in a feature
+    * Implements the select-by-location mechanism for each entity in the feature
+    """
+
+    def __init__(self, entity=None, line_data=None):
+        if entity and not line_data:
+            line_data = self.make_line_data_for(entity)
+        self.entity = entity
+        self.data = OrderedDict(line_data or [])
+        self._line_numbers = None
+        self._line_entities = None
+
+    def select_run_item_by_line(self, line):
+        """Select one run-items by using the line number.
+
+        * Exact match returns run-time entity (Feature, Rule, ScenarioOutline, Scenario)
+        * Any other line in between uses the predecessor entity
+
+        :param line: Line number in Feature file (as int)
+        :return: Selected run-item object.
+        """
+        run_item = self.data.get(line, None)
+        if run_item is None:
+            # -- CASE: BEST-MATCH in ordered line database
+            if self._line_numbers is None:
+                self._line_numbers = list(self.data.keys())
+                self._line_entities = list(self.data.values())
+
+            pos = bisect(self._line_numbers, line) - 1
+            if pos < 0:
+                pos = 0
+            run_item = self._line_entities[pos]
+        return run_item
+
+    def select_scenarios_by_line(self, line):
+        """Select one or more scenarios by using the line number.
+
+        * line = 0: Selects all scenarios in the Feature file
+        * Feature / Rule / ScenarioOutline.location.line selects its scenarios
+        * Scenario.location.line selects the Scenario
+        * Any other lines use the predecessor entity (and its scenarios)
+
+        :param line: Line number in Feature file (as int)
+        :return: List of selected scenarios
+        """
+        run_item = self.select_run_item_by_line(line)
+        scenarios = []
+        if isinstance(run_item, Feature):
+            scenarios = list(run_item.walk_scenarios())
+        elif isinstance(run_item, Rule):
+            scenarios = list(run_item.walk_scenarios())
+        elif isinstance(run_item, ScenarioOutline):
+            scenarios = list(run_item.scenarios)
+        elif isinstance(run_item, Scenario):
+            scenarios = [run_item]
+        return scenarios
+
+    @classmethod
+    def make_line_data_for(cls, entity):
+        line_data = []
+        run_items = []
+        if isinstance(entity, Feature):
+            line_data.append((0, entity))
+            run_items = entity.run_items
+        elif isinstance(entity, Rule):
+            run_items = entity.run_items
+        elif isinstance(entity, ScenarioOutline):
+            run_items = entity.scenarios
+
+        line_data.append((entity.location.line, entity))
+        for run_item in run_items:
+            line_data.extend(cls.make_line_data_for(run_item))
+        # -- MAYBE:
+        # if isinstance(entity, ScenarioOutline) and run_items:
+        #     # -- SPECIAL CASE: Lines after last Examples row => Use ScenarioOutline
+        #     line_data.append((run_items[-1].location.line + 1, entity))
+        return sorted(line_data)
+
+    @classmethod
+    def make(cls, entity):
+        return cls(entity, cls.make_line_data_for(entity))
+
+
+
 class FeatureScenarioLocationCollector(object):
     """
     Collects FileLocation objects for a feature.
@@ -200,6 +294,94 @@ class FeatureScenarioLocationCollector(object):
         return self.feature
 
 
+class FeatureScenarioLocationCollector1(FeatureScenarioLocationCollector):
+
+    @staticmethod
+    def select_scenario_line_for(line, scenario_lines):
+        """
+        Select scenario line for any given line.
+
+        ALGORITHM: scenario.line <= line < next_scenario.line
+
+        :param line:  A line number in the file (as number).
+        :param scenario_lines: Sorted list of scenario lines.
+        :return: Scenario.line (first line) for the given line.
+        """
+        if not scenario_lines:
+            return 0    # -- Select all scenarios.
+        pos = bisect(scenario_lines, line) - 1
+        if pos < 0:
+            pos = 0
+        return scenario_lines[pos]
+
+    def discover_selected_scenarios(self, strict=False):
+        """
+        Discovers selected scenarios based on the provided file locations.
+        In addition:
+          * discover all scenarios
+          * auto-correct BAD LINE-NUMBERS
+
+        :param strict:  If true, raises exception if file location is invalid.
+        :return: List of selected scenarios of this feature (as set).
+        :raises InvalidFileLocationError:
+            If file location is no exactly correct and strict is true.
+        """
+        assert self.feature
+        if not self.all_scenarios:
+            self.all_scenarios = self.feature.walk_scenarios()
+
+        # -- STEP: Check if lines are correct.
+        existing_lines = [scenario.line for scenario in self.all_scenarios]
+        selected_lines = list(self.scenario_lines)
+        for line in selected_lines:
+            new_line = self.select_scenario_line_for(line, existing_lines)
+            if new_line != line:
+                # -- AUTO-CORRECT BAD-LINE:
+                self.scenario_lines.remove(line)
+                self.scenario_lines.add(new_line)
+                if strict:
+                    msg = "Scenario location '...:%d' should be: '%s:%d'" % \
+                          (line, self.filename, new_line)
+                    raise InvalidFileLocationError(msg)
+
+        # -- STEP: Determine selected scenarios and store them.
+        scenario_lines = set(self.scenario_lines)
+        selected_scenarios = set()
+        for scenario in self.all_scenarios:
+            if scenario.line in scenario_lines:
+                selected_scenarios.add(scenario)
+                scenario_lines.remove(scenario.line)
+        # -- CHECK ALL ARE RESOLVED:
+        assert not scenario_lines
+        return selected_scenarios
+
+
+class FeatureScenarioLocationCollector2(FeatureScenarioLocationCollector):
+
+    def discover_selected_scenarios(self, strict=False):
+        """Discovers selected scenarios based on the provided file locations.
+        In addition:
+          * discover all scenarios
+          * auto-correct BAD LINE-NUMBERS
+
+        :param strict:  If true, raises exception if file location is invalid.
+        :return: List of selected scenarios of this feature (as set).
+        :raises InvalidFileLocationError:
+            If file location is no exactly correct and strict is true.
+        """
+        assert self.feature
+        if not self.all_scenarios:
+            self.all_scenarios = self.feature.walk_scenarios()
+
+        line_database = FeatureLineDatabase.make(self.feature)
+        selected_lines = list(self.scenario_lines)
+        selected_scenarios = set()
+        for line in selected_lines:
+            more_scenarios = line_database.select_scenarios_by_line(line)
+            selected_scenarios.update(more_scenarios)
+        return selected_scenarios
+
+
 class FeatureListParser(object):
     """
     Read textual file, ala '@features.txt'. This file contains:
@@ -304,7 +486,7 @@ def parse_features(feature_files, language=None):
     :param language:      Default language to use.
     :return: List of feature objects.
     """
-    scenario_collector = FeatureScenarioLocationCollector()
+    scenario_collector = FeatureScenarioLocationCollector2()
     features = []
     for location in feature_files:
         if not isinstance(location, FileLocation):
@@ -315,7 +497,7 @@ def parse_features(feature_files, language=None):
             scenario_collector.add_location(location)
             continue
         elif scenario_collector.feature:
-            # -- ADD CURRENT FEATURE: As collection of scenarios.
+            # -- NEW FEATURE DETECTED: Add current feature.
             current_feature = scenario_collector.build_feature()
             features.append(current_feature)
             scenario_collector.clear()
diff --git a/features/runner.select_scenarios_by_file_location.feature b/features/runner.select_scenarios_by_file_location.feature
index f60c43f..69e23fe 100644
--- a/features/runner.select_scenarios_by_file_location.feature
+++ b/features/runner.select_scenarios_by_file_location.feature
@@ -13,15 +13,28 @@ Feature: Select Scenarios by File Location
     .   * A file location with filename but without line number
     .     refers to the complete file
     .   * A file location with line number 0 (zero) refers to the complete file
+    .   * A file location within a scenario container (Feature, Rule, ScenarioOutline),
+    .     that does not refer to the file location within a scenario,
+    .     selects all scenarios of this scenario container.
     .
     . SPECIFICATION: Scenario selection by file locations
     .   * scenario.line == file_location.line selects scenario (preferred method).
     .   * Any line number in the following range is acceptable:
-    .        scenario.line <= file_location.line < next_scenario.line
-    .   * The first scenario is selected,
-    .     if the file location line number is less than first scenario.line.
+    .        scenario.line <= file_location.line < next_entity.line (maybe: scenario)
+    .   * If the file location line number is less than first scenario.line,
+    .     the preceeding scenario container (Feature or Rule) is selected.
     .   * The last scenario is selected,
     .     if the file location line number is greater than the lines in the file.
+    .   * For ScenarioOutline.scenarios:
+    .         scenario.line == ScenarioOutline.examples[x].row.line
+    .     The line number of the Examples row that created the scenario is assigned to it.
+    .
+    . SPECIFICATION: "Scenario container" selection by file locations
+    .   * Scenario containers are: Feature, Rule, ScenarioOutline
+    .   * A file location that points into the matching range of a scenario container,
+    .     selects all scenarios / run-items within this scenario container.
+    .   * Any line number in the following range selects the scenario container:
+    .        entity.line <= file_location.line < next_entity.line (maybe: child)
     .
     . SPECIFICATION: Runner with scenario locations (file locations)
     .   * Adjacent file locations are merged if they refer to the same file, like:
@@ -162,22 +175,24 @@ Feature: Select Scenarios by File Location
             """
 
     @file_location.select_first
-    Scenario: Select first scenario if line number is smaller than first scenario line
+    Scenario: Select all scenarios if line number is smaller than first scenario line
 
       CASE: 0 < file_location.line < first_scenario.line
+      HINT: Any line number outside of a scenario may point into a "scenario container".
+            In this case, all the scenarios of the scenario container are selected.
 
         When I run "behave -f plain --dry-run --no-skipped features/alice.feature:1"
         Then it should pass with:
             """
             0 features passed, 0 failed, 0 skipped, 1 untested
-            0 scenarios passed, 0 failed, 1 skipped, 1 untested
+            0 scenarios passed, 0 failed, 0 skipped, 2 untested
             """
         And the command output should contain:
             """
             Feature: Alice
               Scenario: Alice First
             """
-        But the command output should not contain:
+        But the command output should contain:
             """
             Scenario: Alice Last
             """
diff --git a/pytest.ini b/pytest.ini
index a686596..ff2a8a2 100644
--- a/pytest.ini
+++ b/pytest.ini
@@ -16,7 +16,7 @@
 # ============================================================================
 
 [pytest]
-minversion    = 4.2
+minversion    = 2.8
 testpaths     = tests
 python_files  = test_*.py
 addopts = --metadata PACKAGE_UNDER_TEST behave
diff --git a/tests/unit/test_runner_util.py b/tests/unit/test_runner_util.py
new file mode 100644
index 0000000..b5019b8
--- /dev/null
+++ b/tests/unit/test_runner_util.py
@@ -0,0 +1,175 @@
+# -*- coding: UTF-8 -*-
+
+from __future__ import absolute_import, print_function
+from collections import OrderedDict
+from behave.runner_util import FeatureLineDatabase
+from behave.parser import parse_feature
+from behave.model import Feature, Rule, ScenarioOutline, Scenario, Background
+import pytest
+
+
+# ---------------------------------------------------------------------------------------
+# TEST DATA: FeatureLineDatabase
+# ---------------------------------------------------------------------------------------
+feature_text1 = u"""
+    Feature: Alice
+        Background: Alice.Background
+          Given a background step passes
+          
+        Scenario: A1
+          Given a scenario step passes
+
+        Scenario: A2
+          Given a scenario step passes
+          When a scenario step passes
+    """
+
+feature_text_with_scenario_outline = u"""
+    Feature: Bob
+    
+        Scenario Outline: Bob.SO_2_<row.id>
+          Given a person with name "<Name>"
+          Then the person is born in <Birthyear>
+        
+          Examples:
+            | Name  | Birthyear |
+            | Alice |  1990     |
+            | Bob   |  1991     |
+            
+        Scenario: Bob.S3
+          Given a scenario step passes
+          When a scenario step passes
+    """
+
+feature_text_with_rule = u"""
+    Feature: Charly
+        Background: Charly.Background
+          Given a background step passes
+
+        Scenario: C1
+          Given a scenario step passes
+
+        Rule: Charly.Rule_1
+
+          Scenario: Rule_1.C2
+            Given a scenario step passes
+            When a scenario step passes
+    """
+
+feature_file_map = {
+    "basic.feature": feature_text1,
+    "scenario_outline.feature": feature_text_with_scenario_outline,
+    "rule.feature": feature_text_with_rule,
+}
+
+# ---------------------------------------------------------------------------------------
+# TEST SUITE FOR: FeatureLineDatabase
+# ---------------------------------------------------------------------------------------
+class TestFeatureLineDatabase(object):
+    def test_make(self):
+        feature = parse_feature(feature_text1.strip(),
+                                filename="features/Alice.feature")
+        scenario_0 = feature.scenarios[0]
+        scenario_1 = feature.scenarios[1]
+
+        line_database = FeatureLineDatabase.make(feature)
+        expected = OrderedDict([
+            (0, feature),
+            (feature.location.line, feature),
+            (scenario_0.line, scenario_0),
+            (scenario_1.line, scenario_1),
+        ])
+        assert line_database.data == expected
+        assert feature.location.line == 1
+
+    def test_make__with_scenario_outline(self):
+        feature = parse_feature(feature_text_with_scenario_outline.strip(),
+                                filename="features/Bob.feature")
+        scenarios = feature.walk_scenarios(with_outlines=True)
+        scenario_outline = scenarios[0]
+        assert scenario_outline is feature.run_items[0]
+        scenario_1 = scenarios[1]
+        scenario_2 = scenarios[2]
+        scenario_3 = scenarios[3]
+
+        line_database = FeatureLineDatabase.make(feature)
+        expected = OrderedDict([
+            (0, feature),
+            (feature.location.line, feature),
+            (scenario_outline.line, scenario_outline),
+            (scenario_1.line, scenario_1),
+            (scenario_2.line, scenario_2),
+            (scenario_3.line, scenario_3),
+        ])
+        assert line_database.data == expected
+        assert feature.location.line < scenario_outline.location.line
+        assert scenario_outline.location.line < scenario_1.location.line
+        assert scenario_1.location.line < scenario_2.location.line
+        assert scenario_2.location.line < scenario_3.location.line
+
+
+    def test_select_run_items_by_line__feature_line_selects_feature(self):
+        feature = parse_feature(feature_text1, filename="features/Alice.feature")
+        line_database = FeatureLineDatabase.make(feature)
+        selected = line_database.select_run_item_by_line(feature.location.line)
+        assert selected is feature
+        assert isinstance(selected, Feature)
+
+    @pytest.mark.parametrize("filename", [
+        "basic.feature", "scenario_outline.feature", "rule.feature"
+    ])
+    def test_select_run_items_by_line__entity_line_selects_entity(self, filename):
+        feature_text = feature_file_map[filename]
+        feature = parse_feature(feature_text, filename=filename)
+        line_database = FeatureLineDatabase.make(feature)
+        last_line = 0
+        all_run_items = feature.walk_scenarios(with_outlines=True, with_rules=True)
+        for run_item in all_run_items:
+            selected = line_database.select_run_item_by_line(run_item.location.line)
+            assert selected is run_item
+            assert last_line < selected.location.line
+            last_line = run_item.location.line
+
+    @pytest.mark.parametrize("filename", [
+        "basic.feature", "scenario_outline.feature", "rule.feature"
+    ])
+    def test_select_run_items_by_line__line_before_entity_selects_last_entity(self, filename):
+        feature_text = feature_file_map[filename]
+        feature = parse_feature(feature_text, filename=filename)
+        line_database = FeatureLineDatabase.make(feature)
+        all_run_items = feature.walk_scenarios(with_outlines=True, with_rules=True)
+        last_run_item = feature
+        for run_item in all_run_items:
+            predecessor_line = run_item.location.line - 1
+            selected = line_database.select_run_item_by_line(predecessor_line)
+            assert selected is last_run_item
+            assert selected is not run_item
+            last_run_item = run_item
+
+    @pytest.mark.parametrize("filename", [
+        "basic.feature", "scenario_outline.feature", "rule.feature"
+    ])
+    def test_select_run_items_by_line__line_after_entity_selects_entity(self, filename):
+        # -- HINT: In most cases
+        # EXCEPT:
+        #   * Scenarios of ScenarioOutline: scenario.line == SO.examples.row.line
+        #   * Empty entity without steps is directly followed by other entity
+        feature_text = feature_file_map[filename]
+        feature = parse_feature(feature_text, filename=filename)
+        line_database = FeatureLineDatabase.make(feature)
+        all_run_items = feature.walk_scenarios(with_outlines=True, with_rules=True)
+        file_end_line = all_run_items[-1].location.line + 1000
+        for index, run_item in enumerate(all_run_items):
+            next_line = run_item.location.line + 1
+            next_entity_line = file_end_line
+            if index+1 < len(all_run_items):
+                next_entity = all_run_items[index+1]
+                next_entity_line = next_entity.line
+            if next_line >= next_entity_line:
+                # -- EXCLUDE: Scenarios in a ScenarioOutline
+                print("EXCLUDED: %s: %s (line=%s)" %
+                      (run_item.keyword, run_item.name, run_item.line))
+                continue
+
+            selected = line_database.select_run_item_by_line(next_line)
+            assert selected is run_item
